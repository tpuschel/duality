/*
 * Copyright 2017-2021 Thorben Hasenpusch <t.hasenpusch@icloud.com>
 *
 * SPDX-License-Identifier: MIT
 */

#pragma once

#include "constraint.h"
#include "core.h"
#include "type_of.h"
#include "is_subtype.h"
#include "eval.h"

#include "../support/bail.h"

/**
 * The functions here define the 'check' procedure for each object of Core.
 *
 * It has three purposes:
 *   (1) Update the subtype result of every elimination if needed.
 *   (2) Collect the constraints generated by (1).
 *   (3) Resolve inference contexts using the constraints of (2).
 *
 *  'check' is build as a pipeline:
 *   Expression comes in, validated & transformed expression + constraints come out.
 *
 *   Each check function returns true and the new expr in *result if the expr changed, false otherwise.
 */

static inline bool dy_check_expr(struct dy_core_ctx *ctx, struct dy_core_expr expr, struct dy_core_expr *result);

static inline bool dy_check_assumption(struct dy_core_ctx *ctx, struct dy_core_assumption assumption, struct dy_core_assumption *result);

static inline bool dy_check_choice(struct dy_core_ctx *ctx, struct dy_core_choice choice, struct dy_core_choice *result);

static inline bool dy_check_recursion(struct dy_core_ctx *ctx, struct dy_core_recursion recursion, struct dy_core_recursion *result);

static inline bool dy_check_simple(struct dy_core_ctx *ctx, struct dy_core_simple simple, struct dy_core_simple *result);

static inline bool dy_check_elim(struct dy_core_ctx *ctx, struct dy_core_elim elim, struct dy_core_expr *result);

static inline bool dy_check_map_assumption(struct dy_core_ctx *ctx, struct dy_core_map_assumption ass_map, struct dy_core_map_assumption *result);

static inline bool dy_check_map_choice(struct dy_core_ctx *ctx, struct dy_core_map_choice choice_map, struct dy_core_map_choice *result);

static inline bool dy_check_map_recursion(struct dy_core_ctx *ctx, struct dy_core_map_recursion rec_map, struct dy_core_map_recursion *result);

// Doesn't return a bool since an inference context is always resolved.
static inline struct dy_core_expr dy_check_inference_ctx(struct dy_core_ctx *ctx, struct dy_core_inference_ctx inference_ctx);

/**
 * Collects the id of every constraint that mentions 'id' and is not mutually recursive with it.
 * If the size of 'ids' isn't changed upon returning, 'id' is "free" and can be resolved.
 */
static inline void dy_collect_capturing_inference_vars(struct dy_core_ctx *ctx, size_t id, size_t constraint_start, dy_array_t *ids);

static inline bool dy_resolve_inference_var(struct dy_core_ctx *ctx, size_t id, enum dy_polarity polarity, struct dy_core_expr expr, size_t constraint_start, struct dy_core_expr *result);

static inline bool dy_resolve_now_free_inference_vars(struct dy_core_ctx *ctx, size_t id, enum dy_polarity polarity, struct dy_core_expr expr, size_t constraint_start, struct dy_core_expr *result);

static inline bool dy_constraint_binds_id(struct dy_core_ctx *ctx, size_t constraint_id, size_t id);

/**
 * Just removes 'id' from 'ids', if present.
 */
static inline void dy_remove_id(dy_array_t *ids, size_t id);

static inline dy_array_t dy_new_ids_array(struct dy_core_ctx *ctx);

static inline void dy_retire_ids_array(struct dy_core_ctx *ctx, dy_array_t array);

bool dy_check_expr(struct dy_core_ctx *ctx, struct dy_core_expr expr, struct dy_core_expr *result)
{
    switch (expr.tag) {
    case DY_CORE_EXPR_INTRO:
        switch (expr.intro.tag) {
        case DY_CORE_INTRO_COMPLEX:
            switch (expr.intro.complex.tag) {
            case DY_CORE_COMPLEX_ASSUMPTION:
                if (dy_check_assumption(ctx, expr.intro.complex.assumption, &expr.intro.complex.assumption)) {
                    *result = expr;
                    return true;
                } else {
                    return false;
                }
            case DY_CORE_COMPLEX_CHOICE:
                if (dy_check_choice(ctx, expr.intro.complex.choice, &expr.intro.complex.choice)) {
                    *result = expr;
                    return true;
                } else {
                    return false;
                }
            case DY_CORE_COMPLEX_RECURSION:
                if (dy_check_recursion(ctx, expr.intro.complex.recursion, &expr.intro.complex.recursion)) {
                    *result = expr;
                    return true;
                } else {
                    return false;
                }
            }

            dy_bail("impossible");
        case DY_CORE_INTRO_SIMPLE:
            if (dy_check_simple(ctx, expr.intro.simple, &expr.intro.simple)) {
                *result = expr;
                return true;
            } else {
                return false;
            }
        }

        dy_bail("impossible");
    case DY_CORE_EXPR_ELIM:
        return dy_check_elim(ctx, expr.elim, result);
    case DY_CORE_EXPR_MAP:
        switch (expr.map.tag) {
        case DY_CORE_MAP_ASSUMPTION:
            if (dy_check_map_assumption(ctx, expr.map.assumption, &expr.map.assumption)) {
                *result = expr;
                return true;
            } else {
                return false;
            }
        case DY_CORE_MAP_CHOICE:
            if (dy_check_map_choice(ctx, expr.map.choice, &expr.map.choice)) {
                *result = expr;
                return true;
            } else {
                return false;
            }
        case DY_CORE_MAP_RECURSION:
            if (dy_check_map_recursion(ctx, expr.map.recursion, &expr.map.recursion)) {
                *result = expr;
                return true;
            } else {
                return false;
            }
        }

        dy_bail("impossible");
    case DY_CORE_EXPR_VARIABLE:
    case DY_CORE_EXPR_ANY:
    case DY_CORE_EXPR_VOID:
    case DY_CORE_EXPR_INFERENCE_VAR:
        return false;
    case DY_CORE_EXPR_INFERENCE_CTX:
        *result = dy_check_inference_ctx(ctx, expr.inference_ctx);
        return true;
    case DY_CORE_EXPR_CUSTOM: {
        const struct dy_core_custom_shared *vtab = dy_array_pos(&ctx->custom_shared, expr.custom.id);
        return vtab->check(ctx, expr.custom.data, result);
    }
    }

    dy_bail("Impossible object type.");
}

bool dy_check_assumption(struct dy_core_ctx *ctx, struct dy_core_assumption assumption, struct dy_core_assumption *result)
{
    size_t constraint_start1 = ctx->constraints.num_elems;
    struct dy_core_expr type;
    bool type_is_new = dy_check_expr(ctx, *assumption.type, &type);
    if (!type_is_new) {
        type = dy_core_expr_retain(ctx, *assumption.type);
    }

    dy_array_add(&ctx->free_variables, &(struct dy_free_var){
        .id = assumption.id,
        .type = type
    });

    size_t constraint_start2 = ctx->constraints.num_elems;
    struct dy_core_expr expr;
    bool expr_is_new = dy_check_expr(ctx, *assumption.expr, &expr);

    dy_remove_mentions_in_constraints(ctx, assumption.id, constraint_start2);

    --ctx->free_variables.num_elems;

    dy_join_constraints(ctx, constraint_start1, constraint_start2);

    if (!type_is_new && !expr_is_new) {
        dy_core_expr_release(ctx, type);
        return false;
    }

    if (type_is_new) {
        assumption.type = dy_core_expr_new(type);
    } else {
        dy_core_expr_release(ctx, type);
        dy_core_expr_retain_ptr(ctx, assumption.type);
    }

    if (expr_is_new) {
        assumption.expr = dy_core_expr_new(expr);
    } else {
        dy_core_expr_retain_ptr(ctx, assumption.expr);
    }

    *result = assumption;
    return true;
}

bool dy_check_choice(struct dy_core_ctx *ctx, struct dy_core_choice choice, struct dy_core_choice *result)
{
    size_t constraint_start1 = ctx->constraints.num_elems;
    struct dy_core_expr left;
    bool left_is_new = dy_check_expr(ctx, *choice.left, &left);

    size_t constraint_start2 = ctx->constraints.num_elems;
    struct dy_core_expr right;
    bool right_is_new = dy_check_expr(ctx, *choice.right, &right);

    dy_join_constraints(ctx, constraint_start1, constraint_start2);

    if (!left_is_new && !right_is_new) {
        return false;
    }

    if (left_is_new) {
        choice.left = dy_core_expr_new(left);
    } else {
        dy_core_expr_retain_ptr(ctx, choice.left);
    }

    if (right_is_new) {
        choice.right = dy_core_expr_new(right);
    } else {
        dy_core_expr_retain_ptr(ctx, choice.right);
    }

    *result = choice;
    return true;
}

bool dy_check_recursion(struct dy_core_ctx *ctx, struct dy_core_recursion recursion, struct dy_core_recursion *result)
{
    dy_array_add(&ctx->free_variables, &(struct dy_free_var){
        .id = recursion.id,
        .type = {
            .tag = DY_CORE_EXPR_VARIABLE,
            .variable_id = recursion.id
        }
    });

    size_t constraint_start = ctx->constraints.num_elems;

    struct dy_core_expr new_expr;
    bool expr_is_new = dy_check_expr(ctx, *recursion.expr, &new_expr);

    dy_remove_mentions_in_constraints(ctx, recursion.id, constraint_start);

    --ctx->free_variables.num_elems;

    if (!expr_is_new) {
        return false;
    }

    recursion.expr = dy_core_expr_new(new_expr);

    *result = recursion;

    return true;
}

bool dy_check_simple(struct dy_core_ctx *ctx, struct dy_core_simple simple, struct dy_core_simple *result)
{
    if (simple.tag == DY_CORE_SIMPLE_PROOF) {
        size_t constraint_start1 = ctx->constraints.num_elems;
        struct dy_core_expr proof;
        bool proof_is_new = dy_check_expr(ctx, *simple.proof, &proof);

        size_t constraint_start2 = ctx->constraints.num_elems;
        struct dy_core_expr out;
        bool out_is_new = dy_check_expr(ctx, *simple.out, &out);

        dy_join_constraints(ctx, constraint_start1, constraint_start2);

        if (!proof_is_new && !out_is_new) {
            return false;
        }

        if (proof_is_new) {
            simple.proof = dy_core_expr_new(proof);
        } else {
            dy_core_expr_retain_ptr(ctx, simple.proof);
        }

        if (out_is_new) {
            simple.out = dy_core_expr_new(out);
        } else {
            dy_core_expr_retain_ptr(ctx, simple.out);
        }

        *result = simple;
        return true;
    } else {
        struct dy_core_expr out;
        if (!dy_check_expr(ctx, *simple.out, &out)) {
            return false;
        }

        simple.out = dy_core_expr_new(out);
        *result = simple;
        return true;
    }
}

bool dy_check_elim(struct dy_core_ctx *ctx, struct dy_core_elim elim, struct dy_core_expr *result)
{
    size_t recovered_negative_inference_ids_start = ctx->recovered_negative_inference_ids.num_elems;
    size_t recovered_positive_inference_ids_start = ctx->recovered_positive_inference_ids.num_elems;

    size_t constraint_start1 = ctx->constraints.num_elems;
    struct dy_core_expr expr;
    bool expr_is_new = dy_check_expr(ctx, *elim.expr, &expr);
    if (!expr_is_new) {
        expr = dy_core_expr_retain(ctx, *elim.expr);
    }

    size_t constraint_start2 = ctx->constraints.num_elems;
    struct dy_core_simple simple;
    bool simple_is_new = dy_check_simple(ctx, elim.simple, &simple);
    if (!simple_is_new) {
        simple = dy_core_simple_retain(ctx, elim.simple);
    }

    dy_join_constraints(ctx, constraint_start1, constraint_start2);

    dy_ternary_t old_check_result = elim.check_result;
    if (old_check_result == DY_MAYBE) {
        struct dy_core_expr type_of_expr = dy_type_of(ctx, expr);

        struct dy_core_expr simple_expr = {
            .tag = DY_CORE_EXPR_INTRO,
            .intro = {
                .polarity = DY_POLARITY_NEGATIVE,
                .is_implicit = elim.is_implicit,
                .tag = DY_CORE_INTRO_SIMPLE,
                .simple = simple
            }
        };

        constraint_start2 = ctx->constraints.num_elems;

        bool did_transform_expr = false;
        struct dy_core_expr new_expr;
        elim.check_result = dy_is_subtype(ctx, type_of_expr, simple_expr, expr, &new_expr, &did_transform_expr);
        if (did_transform_expr) {
            expr_is_new = true;
            dy_core_expr_release(ctx, expr);
            expr = new_expr;
        }

        dy_join_constraints(ctx, constraint_start1, constraint_start2);

        dy_core_expr_release(ctx, type_of_expr);
    }

    if (expr_is_new) {
        elim.expr = dy_core_expr_new(expr);
    } else {
        dy_core_expr_release(ctx, expr);
        dy_core_expr_retain_ptr(ctx, elim.expr);
    }

    if (simple_is_new) {
        elim.simple = simple;
    } else {
        dy_core_simple_release(ctx, simple);
        dy_core_simple_retain(ctx, elim.simple);
    }

    struct dy_core_expr app = {
        .tag = DY_CORE_EXPR_ELIM,
        .elim = elim
    };

    bool did_eval = false;

    if (elim.eval_immediately) {
        struct dy_core_expr new_app;
        if (dy_eval_elim_single_step(ctx, elim, &new_app)) {
            dy_core_expr_release(ctx, app);
            app = new_app;
            did_eval = true;
        }
    }

    if (!expr_is_new && !simple_is_new && old_check_result == elim.check_result && !did_eval) {
        return false;
    } else {
        for (size_t i = ctx->recovered_negative_inference_ids.num_elems; i-- > recovered_negative_inference_ids_start;) {
            size_t id = *(size_t *)dy_array_pos(&ctx->recovered_negative_inference_ids, i);

            struct dy_core_expr new_app;
            if (dy_resolve_inference_var(ctx, id, DY_POLARITY_NEGATIVE, app, constraint_start1, &new_app)) {
                dy_core_expr_release(ctx, app);
                app = new_app;
            }
        }

        for (size_t i = ctx->recovered_positive_inference_ids.num_elems; i-- > recovered_positive_inference_ids_start;) {
            size_t id = *(size_t *)dy_array_pos(&ctx->recovered_positive_inference_ids, i);

            struct dy_core_expr new_app;
            if (dy_resolve_inference_var(ctx, id, DY_POLARITY_POSITIVE, app, constraint_start1, &new_app)) {
                dy_core_expr_release(ctx, app);
                app = new_app;
            }
        }

        ctx->recovered_negative_inference_ids.num_elems = recovered_negative_inference_ids_start;
        ctx->recovered_positive_inference_ids.num_elems = recovered_positive_inference_ids_start;

        *result = app;

        return true;
    }
}

bool dy_check_map_assumption(struct dy_core_ctx *ctx, struct dy_core_map_assumption ass_map, struct dy_core_map_assumption *result)
{
    size_t constraint_start1 = ctx->constraints.num_elems;
    struct dy_core_expr type;
    bool type_is_new = dy_check_expr(ctx, *ass_map.type, &type);
    if (!type_is_new) {
        type = dy_core_expr_retain(ctx, *ass_map.type);
    }

    dy_array_add(&ctx->free_variables, &(struct dy_free_var){
        .id = ass_map.id,
        .type = type
    });

    size_t constraint_start2 = ctx->constraints.num_elems;
    struct dy_core_assumption new_ass;
    bool ass_is_new = dy_check_assumption(ctx, ass_map.assumption, &new_ass);

    dy_remove_mentions_in_constraints(ctx, ass_map.id, constraint_start2);

    --ctx->free_variables.num_elems;

    dy_join_constraints(ctx, constraint_start1, constraint_start2);

    bool ret = true;
    if (!type_is_new && !ass_is_new) {
        dy_core_expr_release(ctx, type);
        ret = false;
    }

    if (type_is_new) {
        ass_map.type = dy_core_expr_new(type);
    } else {
        dy_core_expr_release(ctx, type);
        dy_core_expr_retain_ptr(ctx, ass_map.type);
    }

    if (ass_is_new) {
        ass_map.assumption = new_ass;
    } else {
        dy_core_assumption_retain(ctx, ass_map.assumption);
    }

    if (ass_map.dependence == DY_CORE_MAP_DEPENDENCE_NOT_CHECKED) {
        dy_array_add(&ctx->free_variables, &(struct dy_free_var){
            .id = ass_map.id,
            .type = *ass_map.type
        });

        dy_array_add(&ctx->free_variables, &(struct dy_free_var){
            .id = ass_map.assumption.id,
            .type = *ass_map.assumption.type
        });

        struct dy_core_expr t = dy_type_of(ctx, *ass_map.assumption.expr);

        if (dy_core_expr_contains_this_variable(ctx, ass_map.assumption.id, t)) {
            ass_map.dependence = DY_CORE_MAP_DEPENDENCE_DEPENDENT;
        } else {
            ass_map.dependence = DY_CORE_MAP_DEPENDENCE_INDEPENDENT;
        }

        --ctx->free_variables.num_elems;
        --ctx->free_variables.num_elems;

        dy_core_expr_release(ctx, t);

        ret = true;
    }

    if (ret) {
        *result = ass_map;
    }
    return true;
}

bool dy_check_map_choice(struct dy_core_ctx *ctx, struct dy_core_map_choice choice_map, struct dy_core_map_choice *result)
{
    size_t constraint_start1 = ctx->constraints.num_elems;
    struct dy_core_assumption left;
    bool left_is_new = dy_check_assumption(ctx, choice_map.assumption_left, &left);

    size_t constraint_start2 = ctx->constraints.num_elems;
    struct dy_core_assumption right;
    bool right_is_new = dy_check_assumption(ctx, choice_map.assumption_right, &right);

    dy_join_constraints(ctx, constraint_start1, constraint_start2);

    if (!left_is_new && !right_is_new) {
        return false;
    }

    if (left_is_new) {
        choice_map.assumption_left = left;
    } else {
        dy_core_assumption_retain(ctx, choice_map.assumption_left);
    }

    if (right_is_new) {
        choice_map.assumption_right = right;
    } else {
        dy_core_assumption_retain(ctx, choice_map.assumption_right);
    }

    if (choice_map.left_dependence == DY_CORE_MAP_DEPENDENCE_NOT_CHECKED) {
        dy_array_add(&ctx->free_variables, &(struct dy_free_var){
            .id = choice_map.assumption_left.id,
            .type = *choice_map.assumption_left.type
        });

        struct dy_core_expr t = dy_type_of(ctx, *choice_map.assumption_left.expr);

        if (dy_core_expr_contains_this_variable(ctx, choice_map.assumption_left.id, t)) {
            choice_map.left_dependence = DY_CORE_MAP_DEPENDENCE_DEPENDENT;
        } else {
            choice_map.left_dependence = DY_CORE_MAP_DEPENDENCE_INDEPENDENT;
        }

        --ctx->free_variables.num_elems;

        dy_core_expr_release(ctx, t);
    }

    if (choice_map.right_dependence == DY_CORE_MAP_DEPENDENCE_NOT_CHECKED) {
        dy_array_add(&ctx->free_variables, &(struct dy_free_var){
            .id = choice_map.assumption_right.id,
            .type = *choice_map.assumption_right.type
        });

        struct dy_core_expr t = dy_type_of(ctx, *choice_map.assumption_right.expr);

        if (dy_core_expr_contains_this_variable(ctx, choice_map.assumption_right.id, t)) {
            choice_map.right_dependence = DY_CORE_MAP_DEPENDENCE_DEPENDENT;
        } else {
            choice_map.right_dependence = DY_CORE_MAP_DEPENDENCE_INDEPENDENT;
        }

        --ctx->free_variables.num_elems;

        dy_core_expr_release(ctx, t);
    }

    *result = choice_map;
    return true;
}

bool dy_check_map_recursion(struct dy_core_ctx *ctx, struct dy_core_map_recursion rec_map, struct dy_core_map_recursion *result)
{
    dy_array_add(&ctx->free_variables, &(struct dy_free_var){
        .id = rec_map.id,
        .type = {
            .tag = DY_CORE_EXPR_VARIABLE,
            .variable_id = rec_map.id
        }
    });

    size_t constraint_start = ctx->constraints.num_elems;

    struct dy_core_assumption new_ass;
    bool ass_is_new = dy_check_assumption(ctx, rec_map.assumption, &new_ass);

    dy_remove_mentions_in_constraints(ctx, rec_map.id, constraint_start);

    --ctx->free_variables.num_elems;

    if (!ass_is_new) {
        return false;
    }

    rec_map.assumption = new_ass;

    if (rec_map.dependence == DY_CORE_MAP_DEPENDENCE_NOT_CHECKED) {
        dy_array_add(&ctx->free_variables, &(struct dy_free_var){
            .id = rec_map.assumption.id,
            .type = *rec_map.assumption.type
        });

        struct dy_core_expr t = dy_type_of(ctx, *rec_map.assumption.expr);

        if (dy_core_expr_contains_this_variable(ctx, rec_map.assumption.id, t)) {
            rec_map.dependence = DY_CORE_MAP_DEPENDENCE_DEPENDENT;
        } else {
            rec_map.dependence = DY_CORE_MAP_DEPENDENCE_INDEPENDENT;
        }

        --ctx->free_variables.num_elems;

        dy_core_expr_release(ctx, t);
    }

    *result = rec_map;

    return true;
}

struct dy_core_expr dy_check_inference_ctx(struct dy_core_ctx *ctx, struct dy_core_inference_ctx inference_ctx)
{
    size_t constraint_start = ctx->constraints.num_elems;

    struct dy_core_expr expr;
    if (!dy_check_expr(ctx, *inference_ctx.expr, &expr)) {
        expr = dy_core_expr_retain(ctx, *inference_ctx.expr);
    }

    struct dy_core_expr expr2;
    if (dy_resolve_inference_var(ctx, inference_ctx.id, inference_ctx.polarity, expr, constraint_start, &expr2)) {
        dy_core_expr_release(ctx, expr);
        expr = expr2;
    }

    return expr;
}

void dy_collect_capturing_inference_vars(struct dy_core_ctx *ctx, size_t id, size_t constraint_start, dy_array_t *ids)
{
    for (size_t i = constraint_start; i < ctx->constraints.num_elems; ++i) {
        const struct dy_constraint *c = dy_array_pos(&ctx->constraints, i);
        if (c->id == id) {
            continue;
        }

        bool duplicate = false;
        for (size_t k = 0, size2 = ids->num_elems; k < size2; ++k) {
            if (c->id == *(const size_t *)dy_array_pos(ids, k)) {
                duplicate = true;
                break;
            }
        }
        if (duplicate) {
            continue;
        }

        if (((c->have_lower && dy_core_expr_contains_this_variable(ctx, id, c->lower)) || (c->have_upper && dy_core_expr_contains_this_variable(ctx, id, c->upper))) && !dy_constraint_binds_id(ctx, id, c->id)) {
            dy_array_add(ids, &c->id);
        }
    }
}

bool dy_resolve_now_free_inference_vars(struct dy_core_ctx *ctx, size_t id, enum dy_polarity polarity, struct dy_core_expr expr, size_t constraint_start, struct dy_core_expr *result)
{
    struct dy_core_expr ret = dy_core_expr_retain(ctx, expr);

    bool did_transform = false;
    for (size_t i = ctx->captured_inference_vars.num_elems; i-- > 0;) {
        struct dy_captured_inference_var *captured_inference_var = dy_array_pos(&ctx->captured_inference_vars, i);

        dy_remove_id(&captured_inference_var->captor_ids, id);

        if (captured_inference_var->captor_ids.num_elems != 0) {
            // Still captured.
            continue;
        }

        dy_retire_ids_array(ctx, captured_inference_var->captor_ids);

        size_t captured_id = captured_inference_var->id;

        dy_array_remove(&ctx->captured_inference_vars, i);

        struct dy_core_expr ret2;
        if (dy_resolve_inference_var(ctx, captured_id, polarity, ret, constraint_start, &ret2)) {
            did_transform = true;
            dy_core_expr_release(ctx, ret);
            ret = ret2;
        }

        i = ctx->captured_inference_vars.num_elems;
    }

    if (!did_transform) {
        dy_core_expr_release(ctx, ret);
        return false;
    } else {
        *result = ret;
        return true;
    }
}

bool dy_resolve_inference_var(struct dy_core_ctx *ctx, size_t id, enum dy_polarity polarity, struct dy_core_expr expr, size_t constraint_start, struct dy_core_expr *result)
{
    dy_array_t captor_ids = dy_new_ids_array(ctx);
    dy_collect_capturing_inference_vars(ctx, id, constraint_start, &captor_ids);

    if (captor_ids.num_elems != 0) {
        dy_array_add(&ctx->captured_inference_vars, &(struct dy_captured_inference_var){
            .id = id,
            .captor_ids = captor_ids,
        });

        return false;
    }

    dy_retire_ids_array(ctx, captor_ids);

    struct dy_core_expr sub;
    bool have_sub = dy_constraint_get(ctx, id, polarity, constraint_start, &sub);

    struct dy_core_expr type_of_expr = dy_type_of(ctx, expr);

    bool positive = false, negative = false;
    dy_variable_appears_in_polarity(ctx, type_of_expr, id, DY_POLARITY_POSITIVE, &positive, &negative);

    dy_core_expr_release(ctx, type_of_expr);

    struct dy_core_expr any = {
        .tag = DY_CORE_EXPR_ANY
    };

    if (positive && negative) {
        if (have_sub) {
            struct dy_core_expr pair = {
                .tag = DY_CORE_EXPR_INTRO,
                .intro = {
                    .polarity = DY_POLARITY_POSITIVE,
                    .is_implicit = true,
                    .tag = DY_CORE_INTRO_COMPLEX,
                    .complex = {
                        .tag = DY_CORE_COMPLEX_CHOICE,
                        .choice = {
                            .left = dy_core_expr_new(sub),
                            .right = dy_core_expr_new((struct dy_core_expr){
                                .tag = DY_CORE_EXPR_VARIABLE,
                                .variable_id = id
                            })
                        }
                    }
                }
            };

            if (!dy_substitute(ctx, expr, id, pair, &expr)) {
                expr = dy_core_expr_retain(ctx, expr);
            }
        } else {
            struct dy_core_expr v = {
                .tag = DY_CORE_EXPR_VARIABLE,
                .variable_id = id
            };

            if (!dy_substitute(ctx, expr, id, v, &expr)) {
                expr = dy_core_expr_retain(ctx, expr);
            }
        }

        expr = (struct dy_core_expr){
            .tag = DY_CORE_EXPR_INTRO,
            .intro = {
                .polarity = DY_POLARITY_POSITIVE,
                .is_implicit = true,
                .tag = DY_CORE_INTRO_COMPLEX,
                .complex = {
                    .tag = DY_CORE_COMPLEX_ASSUMPTION,
                    .assumption = {
                        .id = id,
                        .type = dy_core_expr_new(dy_core_expr_retain(ctx, any)),
                        .expr = dy_core_expr_new(expr)
                    }
                }
            }
        };
    } else {
        if (!dy_substitute(ctx, expr, id, have_sub ? sub : any, &expr)) {
            expr = dy_core_expr_retain(ctx, expr);
        }
    }

    dy_free_constraints_in_range(ctx, constraint_start, ctx->constraints.num_elems);

    struct dy_core_expr new_expr;
    if (dy_check_expr(ctx, expr, &new_expr)) {
        dy_core_expr_release(ctx, expr);
        expr = new_expr;
    }

    if (dy_resolve_now_free_inference_vars(ctx, id, polarity, expr, constraint_start, &new_expr)) {
        dy_core_expr_release(ctx, expr);
        expr = new_expr;
    }

    *result = expr;
    return true;
}

void dy_remove_id(dy_array_t *ids, size_t id_to_remove)
{
    for (size_t i = 0, size = ids->num_elems; i < size; ++i) {
        size_t id = *(size_t *)dy_array_pos(ids, i);

        if (id == id_to_remove) {
            dy_array_remove(ids, i);
            return;
        }
    }
}

void dy_remove_mentions_in_constraints(struct dy_core_ctx *ctx, size_t id, size_t start)
{
    for (size_t i = start, size = ctx->constraints.num_elems; i < size; ++i) {
        struct dy_constraint *c = dy_array_pos(&ctx->constraints, i);

        struct dy_core_expr e;
        if (c->have_lower && dy_remove_mentions_in_type(ctx, id, DY_POLARITY_POSITIVE, c->lower, &e)) {
            dy_core_expr_release(ctx, c->lower);
            c->lower = e;
        }

        if (c->have_upper && dy_remove_mentions_in_type(ctx, id, DY_POLARITY_NEGATIVE, c->upper, &e)) {
            dy_core_expr_release(ctx, c->upper);
            c->upper = e;
        }
    }
}

bool dy_remove_mentions_in_type(struct dy_core_ctx *ctx, size_t id, enum dy_polarity current_polarity, struct dy_core_expr type, struct dy_core_expr *result)
{
    switch (type.tag) {
    case DY_CORE_EXPR_INTRO:
        switch (type.intro.tag) {
        case DY_CORE_INTRO_COMPLEX:
            switch (type.intro.complex.tag) {
            case DY_CORE_COMPLEX_ASSUMPTION: {
                struct dy_core_expr t;
                bool type_is_new = dy_remove_mentions_in_type(ctx, id, dy_flip_polarity(current_polarity), *type.intro.complex.assumption.type, &t);

                struct dy_core_expr expr;
                bool expr_is_new = dy_remove_mentions_in_type(ctx, id, current_polarity, *type.intro.complex.assumption.expr, &expr);

                if (!type_is_new && !expr_is_new) {
                    return false;
                }

                if (type_is_new) {
                    type.intro.complex.assumption.type = dy_core_expr_new(t);
                } else {
                    dy_core_expr_retain_ptr(ctx, type.intro.complex.assumption.type);
                }

                if (expr_is_new) {
                    type.intro.complex.assumption.expr = dy_core_expr_new(expr);
                } else {
                    dy_core_expr_retain_ptr(ctx, type.intro.complex.assumption.expr);
                }

                *result = type;
                return true;
            }
            case DY_CORE_COMPLEX_CHOICE: {
                struct dy_core_expr left;
                bool left_is_new = dy_remove_mentions_in_type(ctx, id, current_polarity, *type.intro.complex.choice.left, &left);

                struct dy_core_expr right;
                bool right_is_new = dy_remove_mentions_in_type(ctx, id, current_polarity, *type.intro.complex.choice.right, &right);

                if (!left_is_new && !right_is_new) {
                    return false;
                }

                if (left_is_new) {
                    type.intro.complex.choice.left = dy_core_expr_new(left);
                } else {
                    dy_core_expr_retain_ptr(ctx, type.intro.complex.choice.left);
                }

                if (right_is_new) {
                    type.intro.complex.choice.right = dy_core_expr_new(right);
                } else {
                    dy_core_expr_retain_ptr(ctx, type.intro.complex.choice.right);
                }

                *result = type;
                return true;
            }
            case DY_CORE_COMPLEX_RECURSION: {
                struct dy_core_expr expr;
                if (!dy_remove_mentions_in_type(ctx, id, current_polarity, *type.intro.complex.recursion.expr, &expr)) {
                    return false;
                }

                type.intro.complex.recursion.expr = dy_core_expr_new(expr);

                *result = type;
                return true;
            }
            }

            dy_bail("impossible");
        case DY_CORE_INTRO_SIMPLE:
            if (type.intro.simple.tag == DY_CORE_SIMPLE_PROOF && dy_core_expr_contains_this_variable(ctx, id, *type.intro.simple.proof)) {
                struct dy_core_expr fun = {
                    .tag = DY_CORE_EXPR_INTRO,
                    .intro = {
                        .polarity = current_polarity == type.intro.polarity ? dy_flip_polarity(current_polarity) : current_polarity,
                        .is_implicit = type.intro.is_implicit,
                        .tag = DY_CORE_INTRO_COMPLEX,
                        .complex = {
                            .tag = DY_CORE_COMPLEX_ASSUMPTION,
                            .assumption = {
                                .id = ctx->running_id++,
                                .type = dy_core_expr_new(dy_type_of(ctx, *type.intro.simple.proof)),
                                .expr = dy_core_expr_retain_ptr(ctx, type.intro.simple.out)
                            }
                        }
                    }
                };

                if (dy_remove_mentions_in_type(ctx, id, current_polarity, fun, result)) {
                    dy_core_expr_release(ctx, fun);
                } else {
                    *result = fun;
                }

                return true;
            } else {
                struct dy_core_expr out;
                if (!dy_remove_mentions_in_type(ctx, id, current_polarity, *type.intro.simple.out, &out)) {
                    return false;
                }

                type.intro.simple.out = dy_core_expr_new(out);

                *result = type;
                return true;
            }
        }

        dy_bail("impossible");
    case DY_CORE_EXPR_ELIM:
        if (dy_core_expr_contains_this_variable(ctx, id, type)) {
            *result = (struct dy_core_expr){
                .tag = DY_CORE_EXPR_ANY
            };

            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_MAP:
        if (dy_core_expr_contains_this_variable(ctx, id, type)) {
            *result = (struct dy_core_expr){
                .tag = DY_CORE_EXPR_ANY
            };

            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_VARIABLE:
        if (type.variable_id == id) {
            *result = (struct dy_core_expr){
                .tag = DY_CORE_EXPR_ANY
            };

            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_INFERENCE_VAR:
        if (type.inference_var_id == id) {
            *result = (struct dy_core_expr){
                .tag = DY_CORE_EXPR_ANY
            };

            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_ANY:
    case DY_CORE_EXPR_VOID:
        return false;
    case DY_CORE_EXPR_INFERENCE_CTX:
        dy_bail("impossible");
    case DY_CORE_EXPR_CUSTOM: {
        const struct dy_core_custom_shared *s = dy_array_pos(&ctx->custom_shared, type.custom.id);
        return s->remove_mentions_in_type(ctx, type.custom.data, id, current_polarity, result);
    }
    }

    dy_bail("Impossible object type.");
}

dy_array_t dy_new_ids_array(struct dy_core_ctx *ctx)
{
    if (ctx->free_ids_arrays.num_elems == 0) {
        return dy_array_create(sizeof(size_t), DY_ALIGNOF(size_t), 4);
    } else {
        dy_array_t x;
        dy_array_pop(&ctx->free_ids_arrays, &x);
        return x;
    }
}

void dy_retire_ids_array(struct dy_core_ctx *ctx, dy_array_t array)
{
    dy_array_add(&ctx->free_ids_arrays, &array);
}

bool dy_constraint_binds_id(struct dy_core_ctx *ctx, size_t constraint_id, size_t id)
{
    for (size_t i = 0; i < ctx->constraints.num_elems; ++i) {
        const struct dy_constraint *c = dy_array_pos(&ctx->constraints, i);
        if (c->id != constraint_id) {
            continue;
        }

        if (c->have_lower && c->lower.tag == DY_CORE_EXPR_INFERENCE_VAR && c->lower.inference_var_id == id) {
            return true;
        }

        if (c->have_upper && c->upper.tag == DY_CORE_EXPR_INFERENCE_VAR && c->upper.inference_var_id == id) {
            return true;
        }

        return false;
    }

    return false;
}
