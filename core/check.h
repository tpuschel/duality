/*
 * Copyright 2017-2020 Thorben Hasenpusch <t.hasenpusch@icloud.com>
 *
 * SPDX-License-Identifier: MIT
 */

#pragma once

#include "constraint.h"
#include "core.h"
#include "type_of.h"
#include "is_subtype.h"

#include "../support/bail.h"

/**
 * The functions here define the 'check' procedure for each object of Core.
 *
 * It has three purposes:
 *   (1) Update the subtype result of every elimination & recursion if needed.
 *   (2) Collect the constraints generated by (1).
 *   (3) Resolve inference contexts using the constraints of (2).
 *
 *  'check' is build as a pipeline:
 *   Expression comes in, validated & transformed expression + constraints come out.
 */

static inline bool dy_check_expr(struct dy_core_ctx *ctx, struct dy_core_expr expr, struct dy_constraint *constraint, bool *did_generate_constraint, struct dy_core_expr *result);

static inline bool dy_check_equality_map(struct dy_core_ctx *ctx, struct dy_core_equality_map equality_map, struct dy_constraint *constraint, bool *did_generate_constraint, struct dy_core_equality_map *result);

static inline bool dy_check_type_map(struct dy_core_ctx *ctx, struct dy_core_type_map type_map, struct dy_constraint *constraint, bool *did_generate_constraint, struct dy_core_type_map *result);

static inline bool dy_check_equality_map_elim(struct dy_core_ctx *ctx, struct dy_core_equality_map_elim elim, struct dy_constraint *constraint, bool *did_generate_constraint, struct dy_core_expr *result);

static inline bool dy_check_type_map_elim(struct dy_core_ctx *ctx, struct dy_core_type_map_elim elim, struct dy_constraint *constraint, bool *did_generate_constraint, struct dy_core_expr *result);

static inline bool dy_check_junction(struct dy_core_ctx *ctx, struct dy_core_junction junction, struct dy_constraint *constraint, bool *did_generate_constraint, struct dy_core_junction *result);

static inline bool dy_check_alternative(struct dy_core_ctx *ctx, struct dy_core_alternative alternative, struct dy_constraint *constraint, bool *did_generate_constraint, struct dy_core_alternative *result);

static inline struct dy_core_expr dy_check_inference_type_map(struct dy_core_ctx *ctx, struct dy_core_inference_type_map inference_type_map, struct dy_constraint *constraint, bool *did_generate_constraint);

static inline bool dy_check_recursion(struct dy_core_ctx *ctx, struct dy_core_recursion recursion, struct dy_constraint *constraint, bool *did_generate_constraint, struct dy_core_expr *result);

/**
 * Collects the id of every constraint that mentions 'id'.
 * If the size of 'ids' isn't changed upon returning, 'id' is "free" and can be resolved.
 */
static inline void dy_binding_contraints(struct dy_core_ctx *ctx, size_t id, struct dy_constraint constraint, bool have_constraint, dy_array_t *ids);

static inline bool dy_is_dependency_of_constraint(struct dy_core_ctx *ctx, size_t potential_dependency_id, size_t current_constraint_id);

static inline bool dy_free_constraint(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr expr, struct dy_constraint c, bool have_c, struct dy_constraint *c_out, bool *have_c_out, struct dy_core_expr *result);

static inline bool resolve_inference_var(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr type, enum dy_core_polarity polarity, struct dy_core_expr expr, struct dy_constraint c_in, bool have_c_in, struct dy_constraint *c_out, bool *have_c_out, struct dy_core_expr *result);

/**
 * Just removes 'id' from 'ids', if present.
 */
static inline void remove_id(dy_array_t *ids, size_t id);

/**
 * Removes all mentions of 'id' in 'constraint', which may involve lowering/raising the subtype/supertype bounds.
 */
static inline bool remove_mentions_in_constraint(struct dy_core_ctx *ctx, size_t id, struct dy_constraint constraint, struct dy_constraint *result);

/**
 * Removes all mentions of 'id'. The returned type is always a supertype of 'subtype'.
 */
static inline bool remove_mentions_in_subtype(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr subtype, struct dy_core_expr *result);

/**
 * Removes all mentions of 'id'. The returned type is always a subtype of 'supertype'.
 */
static inline bool remove_mentions_in_supertype(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr supertype, struct dy_core_expr *result);

static inline void dy_join_constraints3(struct dy_constraint c1, bool have_c1, struct dy_constraint c2, bool have_c2, struct dy_constraint c3, bool have_c3, struct dy_constraint *c4, bool *have_c4);

static inline dy_array_t dy_new_ids_array(struct dy_core_ctx *ctx);

static inline void dy_retire_ids_array(struct dy_core_ctx *ctx, dy_array_t array);

bool dy_check_expr(struct dy_core_ctx *ctx, struct dy_core_expr expr, struct dy_constraint *constraint, bool *did_generate_constraint, struct dy_core_expr *result)
{
    switch (expr.tag) {
    case DY_CORE_EXPR_EQUALITY_MAP:
        if (dy_check_equality_map(ctx, expr.equality_map, constraint, did_generate_constraint, &expr.equality_map)) {
            *result = expr;
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_TYPE_MAP:
        if (dy_check_type_map(ctx, expr.type_map, constraint, did_generate_constraint, &expr.type_map)) {
            *result = expr;
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_EQUALITY_MAP_ELIM:
        if (dy_check_equality_map_elim(ctx, expr.equality_map_elim, constraint, did_generate_constraint, &expr)) {
            *result = expr;
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_TYPE_MAP_ELIM:
        if (dy_check_type_map_elim(ctx, expr.type_map_elim, constraint, did_generate_constraint, &expr)) {
            *result = expr;
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_JUNCTION:
        if (dy_check_junction(ctx, expr.junction, constraint, did_generate_constraint, &expr.junction)) {
            *result = expr;
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_RECURSION:
        if (dy_check_recursion(ctx, expr.recursion, constraint, did_generate_constraint, &expr)) {
            *result = expr;
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_ALTERNATIVE:
        if (dy_check_alternative(ctx, expr.alternative, constraint, did_generate_constraint, &expr.alternative)) {
            *result = expr;
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_INFERENCE_TYPE_MAP:
        *result = dy_check_inference_type_map(ctx, expr.inference_type_map, constraint, did_generate_constraint);
        return true;
    case DY_CORE_EXPR_VARIABLE:
        return false;
    case DY_CORE_EXPR_END:
        return false;
    case DY_CORE_EXPR_CUSTOM:
        return expr.custom.check(expr.custom.data, ctx, constraint, did_generate_constraint, result);
    case DY_CORE_EXPR_SYMBOL:
        return false;
    }

    dy_bail("Impossible object type.");
}

bool dy_check_equality_map(struct dy_core_ctx *ctx, struct dy_core_equality_map equality_map, struct dy_constraint *constraint, bool *did_generate_constraint, struct dy_core_equality_map *result)
{
    struct dy_constraint c1;
    bool have_c1 = false;
    struct dy_core_expr e1;
    bool e1_is_new = dy_check_expr(ctx, *equality_map.e1, &c1, &have_c1, &e1);

    struct dy_constraint c2;
    bool have_c2 = false;
    struct dy_core_expr e2;
    bool e2_is_new = dy_check_expr(ctx, *equality_map.e2, &c2, &have_c2, &e2);
    
    dy_join_constraints(c1, have_c1, DY_CORE_POLARITY_POSITIVE, c2, have_c2, constraint, did_generate_constraint);

    if (!e1_is_new && !e2_is_new) {
        return false;
    }
    
    if (e1_is_new) {
        equality_map.e1 = dy_core_expr_new(e1);
    } else {
        dy_core_expr_retain_ptr(equality_map.e1);
    }
    
    if (e2_is_new) {
        equality_map.e2 = dy_core_expr_new(e2);
    } else {
        dy_core_expr_retain_ptr(equality_map.e2);
    }
    
    *result = equality_map;
    return true;
}

bool dy_check_type_map(struct dy_core_ctx *ctx, struct dy_core_type_map type_map, struct dy_constraint *constraint, bool *did_generate_constraint, struct dy_core_type_map *result)
{
    struct dy_constraint c1;
    bool have_c1 = false;
    struct dy_core_expr type;
    bool type_is_new = dy_check_expr(ctx, *type_map.type, &c1, &have_c1, &type);
    if (!type_is_new) {
        type = dy_core_expr_retain(*type_map.type);
    }

    dy_array_add(&ctx->bindings, &(struct dy_core_binding){
        .id = type_map.id,
        .type = type,
        .is_inference_var = false
    });

    struct dy_constraint c2;
    bool have_c2 = false;
    struct dy_core_expr expr;
    bool expr_is_new = dy_check_expr(ctx, *type_map.expr, &c2, &have_c2, &expr);

    if (have_c2) {
        struct dy_constraint c3;
        if (remove_mentions_in_constraint(ctx, type_map.id, c2, &c3)) {
            dy_constraint_release(c2);
            c2 = c3;
        }
    }

    --ctx->bindings.num_elems;

    dy_join_constraints(c1, have_c1, DY_CORE_POLARITY_POSITIVE, c2, have_c2, constraint, did_generate_constraint);
    
    if (!type_is_new && !expr_is_new) {
        return false;
    }
    
    if (type_is_new) {
        type_map.type = dy_core_expr_new(type);
    } else {
        dy_core_expr_release(type);
        dy_core_expr_retain_ptr(type_map.type);
    }
    
    if (expr_is_new) {
        type_map.expr = dy_core_expr_new(expr);
    } else {
        dy_core_expr_retain_ptr(type_map.expr);
    }

    *result = type_map;
    return true;
}

bool dy_check_equality_map_elim(struct dy_core_ctx *ctx, struct dy_core_equality_map_elim elim, struct dy_constraint *constraint, bool *did_generate_constraint, struct dy_core_expr *result)
{
    struct dy_constraint c1;
    bool have_c1 = false;
    struct dy_core_expr expr;
    bool expr_is_new = dy_check_expr(ctx, *elim.expr, &c1, &have_c1, &expr);
    if (!expr_is_new) {
        expr = dy_core_expr_retain(*elim.expr);
    }

    struct dy_constraint c2;
    bool have_c2 = false;
    struct dy_core_equality_map eq_map;
    bool eq_map_is_new = dy_check_equality_map(ctx, elim.map, &c2, &have_c2, &eq_map);
    if (!eq_map_is_new) {
        eq_map = elim.map;
        dy_core_expr_retain_ptr(eq_map.e1);
        dy_core_expr_retain_ptr(eq_map.e2);
    }
    
    size_t subtype_implicits_old_size = ctx->subtype_implicits.num_elems;

    struct dy_constraint c3;
    bool have_c3 = false;
    dy_ternary_t check_result = elim.check_result;
    if (check_result == DY_MAYBE) {
        struct dy_core_expr type_of_expr = dy_type_of(ctx, expr);

        if (dy_core_expr_is_computation(*eq_map.e1)) {
            struct dy_core_expr type_of_equality_map_e1 = dy_type_of(ctx, *eq_map.e1);

            struct dy_core_expr type_map_expr = {
                .tag = DY_CORE_EXPR_TYPE_MAP,
                .type_map = {
                    .id = ctx->running_id++,
                    .type = dy_core_expr_new(type_of_equality_map_e1),
                    .expr = dy_core_expr_retain_ptr(eq_map.e2),
                    .polarity = DY_CORE_POLARITY_POSITIVE,
                    .is_implicit = eq_map.is_implicit,
                }
            };
            
            bool did_transform_expr = false;
            struct dy_core_expr new_expr;
            check_result = dy_is_subtype(ctx, type_of_expr, type_map_expr, &c3, &have_c3, expr, &new_expr, &did_transform_expr);
            if (did_transform_expr) {
                expr_is_new = true;
                dy_core_expr_release(expr);
                expr = new_expr;
            }

            dy_core_expr_release(type_map_expr);
        } else {
            struct dy_core_expr equality_map_expr = {
                .tag = DY_CORE_EXPR_EQUALITY_MAP,
                .equality_map = eq_map
            };
            
            bool did_transform_expr = false;
            struct dy_core_expr new_expr;
            check_result = dy_is_subtype(ctx, type_of_expr, equality_map_expr, &c3, &have_c3, expr, &new_expr, &did_transform_expr);
            if (did_transform_expr) {
                expr_is_new = true;
                dy_core_expr_release(expr);
                expr = new_expr;
            }
        }

        dy_core_expr_release(type_of_expr);
    }
    
    if (expr_is_new) {
        elim.expr = dy_core_expr_new(expr);
    } else {
        dy_core_expr_release(expr);
        dy_core_expr_retain_ptr(elim.expr);
    }
    
    if (eq_map_is_new) {
        elim.map = eq_map;
    } else {
        dy_core_expr_release_ptr(eq_map.e1);
        dy_core_expr_release_ptr(eq_map.e2);
        dy_core_expr_retain_ptr(elim.map.e1);
        dy_core_expr_retain_ptr(elim.map.e2);
    }
    
    dy_ternary_t old_status = elim.check_result;
    elim.check_result = check_result;

    struct dy_core_expr ret = {
        .tag = DY_CORE_EXPR_EQUALITY_MAP_ELIM,
        .equality_map_elim = elim
    };

    bool transformed = false;
    for (size_t i = subtype_implicits_old_size, size = ctx->subtype_implicits.num_elems; i < size; ++i) {
        struct dy_core_binding b;
        dy_array_pop(&ctx->subtype_implicits, &b);

        struct dy_constraint c4;
        bool have_c4 = false;
        struct dy_core_expr ret2;
        if (resolve_inference_var(ctx, b.id, b.type, DY_CORE_POLARITY_NEGATIVE, ret, c3, have_c3, &c4, &have_c4, &ret2)) {
            transformed = true;
            dy_core_expr_release(ret);
            ret = ret2;
        }
        
        if (have_c3) {
            dy_constraint_release(c3);
        }

        c3 = c4;
        have_c3 = have_c4;
    }

    dy_join_constraints3(c1, have_c1, c2, have_c2, c3, have_c3, constraint, did_generate_constraint);
    
    if (!expr_is_new && !eq_map_is_new && elim.check_result == old_status && !transformed) {
        dy_core_expr_release(ret);
        return false;
    } else {
        *result = ret;
        return true;
    }
}

bool dy_check_type_map_elim(struct dy_core_ctx *ctx, struct dy_core_type_map_elim elim, struct dy_constraint *constraint, bool *did_generate_constraint, struct dy_core_expr *result)
{
    dy_bail("Not yet implemented.");
}

bool dy_check_junction(struct dy_core_ctx *ctx, struct dy_core_junction junction, struct dy_constraint *constraint, bool *did_generate_constraint, struct dy_core_junction *result)
{
    struct dy_constraint c1;
    bool have_c1 = false;
    struct dy_core_expr e1;
    bool e1_is_new = dy_check_expr(ctx, *junction.e1, &c1, &have_c1, &e1);

    struct dy_constraint c2;
    bool have_c2 = false;
    struct dy_core_expr e2;
    bool e2_is_new = dy_check_expr(ctx, *junction.e2, &c2, &have_c2, &e2);

    dy_join_constraints(c1, have_c1, DY_CORE_POLARITY_POSITIVE, c2, have_c2, constraint, did_generate_constraint);
    
    if (!e1_is_new && !e2_is_new) {
        return false;
    }
    
    if (e1_is_new) {
        junction.e1 = dy_core_expr_new(e1);
    } else {
        dy_core_expr_retain_ptr(junction.e1);
    }
    
    if (e2_is_new) {
        junction.e2 = dy_core_expr_new(e2);
    } else {
        dy_core_expr_retain_ptr(junction.e2);
    }

    *result = junction;
    return true;
}

bool dy_check_alternative(struct dy_core_ctx *ctx, struct dy_core_alternative alternative, struct dy_constraint *constraint, bool *did_generate_constraint, struct dy_core_alternative *result)
{
    struct dy_constraint c1;
    bool have_c1 = false;
    struct dy_core_expr first;
    bool first_is_new = dy_check_expr(ctx, *alternative.first, &c1, &have_c1, &first);

    struct dy_constraint c2;
    bool have_c2 = false;
    struct dy_core_expr second;
    bool second_is_new = dy_check_expr(ctx, *alternative.second, &c2, &have_c2, &second);

    dy_join_constraints(c1, have_c1, DY_CORE_POLARITY_NEGATIVE, c2, have_c2, constraint, did_generate_constraint);
    
    if (!first_is_new && !second_is_new) {
        return false;
    }
    
    if (first_is_new) {
        alternative.first = dy_core_expr_new(first);
    } else {
        dy_core_expr_retain_ptr(alternative.first);
    }
    
    if (second_is_new) {
        alternative.second = dy_core_expr_new(second);
    } else {
        dy_core_expr_retain_ptr(alternative.second);
    }

    *result = alternative;
    return true;
}

bool dy_check_recursion(struct dy_core_ctx *ctx, struct dy_core_recursion recursion, struct dy_constraint *constraint, bool *did_generate_constraint, struct dy_core_expr *result)
{
    struct dy_constraint c1;
    bool have_c1 = false;
    struct dy_core_expr type;
    bool type_is_new = dy_check_expr(ctx, *recursion.type, &c1, &have_c1, &type);
    if (!type_is_new) {
        type = dy_core_expr_retain(*recursion.type);
    }

    dy_array_add(&ctx->bindings, &(struct dy_core_binding){
        .id = recursion.id,
        .type = type,
        .is_inference_var = false
    });

    struct dy_constraint c2;
    bool have_c2 = false;
    struct dy_core_expr expr;
    bool expr_is_new = dy_check_expr(ctx, *recursion.expr, &c2, &have_c2, &expr);
    if (!expr_is_new) {
        expr = dy_core_expr_retain(*recursion.expr);
    }
    
    if (have_c2) {
        struct dy_constraint c3;
        if (remove_mentions_in_constraint(ctx, recursion.id, c2, &c3)) {
            dy_constraint_release(c2);
            c2 = c3;
        }
    }
    
    size_t subtype_implicits_old_size = ctx->subtype_implicits.num_elems;
    
    struct dy_constraint c3;
    bool have_c3 = false;
    dy_ternary_t check_result = recursion.check_result;
    if (check_result == DY_MAYBE) {
        struct dy_core_expr type_of_expr = dy_type_of(ctx, expr);
        
        struct dy_core_expr expr2;
        bool did_transform_expr = false;
        check_result = dy_is_subtype(ctx, type_of_expr, type, &c3, &have_c3, expr, &expr2, &did_transform_expr);
        if (did_transform_expr) {
            expr_is_new = true;
            dy_core_expr_release(expr);
            expr = expr2;
        }

        dy_core_expr_release(type_of_expr);
    }
    
    if (type_is_new) {
        recursion.type = dy_core_expr_new(type);
    } else {
        dy_core_expr_release(type);
        dy_core_expr_retain_ptr(recursion.type);
    }
    
    if (expr_is_new) {
        recursion.expr = dy_core_expr_new(expr);
    } else {
        dy_core_expr_release(expr);
        dy_core_expr_retain_ptr(recursion.expr);
    }
    
    dy_ternary_t old_status = recursion.check_result;
    recursion.check_result = check_result;
    
    struct dy_core_expr ret = {
        .tag = DY_CORE_EXPR_RECURSION,
        .recursion = recursion
    };
    
    bool did_transform = false;
    for (size_t i = subtype_implicits_old_size, size = ctx->subtype_implicits.num_elems; i < size; ++i) {
        struct dy_core_binding b;
        dy_array_pop(&ctx->subtype_implicits, &b);

        struct dy_constraint c4;
        bool have_c4 = false;
        struct dy_core_expr ret2;
        if (resolve_inference_var(ctx, b.id, b.type, DY_CORE_POLARITY_NEGATIVE, ret, c3, have_c3, &c4, &have_c4, &ret2)) {
            did_transform = true;
            dy_core_expr_release(ret);
            ret = ret2;
        }
        
        if (have_c3) {
            dy_constraint_release(c3);
        }
        
        c3 = c4;
        have_c3 = have_c4;
    }
    
    if (have_c3) {
        struct dy_constraint c4;
        if (remove_mentions_in_constraint(ctx, recursion.id, c3, &c4)) {
            dy_constraint_release(c3);
            c3 = c4;
        }
    }
    
    --ctx->bindings.num_elems;

    dy_join_constraints3(c1, have_c1, c2, have_c2, c3, have_c3, constraint, did_generate_constraint);
    
    if (!type_is_new && !expr_is_new && recursion.check_result == old_status && !did_transform) {
        dy_core_expr_release(ret);
        return false;
    } else {
        *result = ret;
        return true;
    }
}

struct dy_core_expr dy_check_inference_type_map(struct dy_core_ctx *ctx, struct dy_core_inference_type_map inference_type_map, struct dy_constraint *constraint, bool *did_generate_constraint)
{
    struct dy_constraint c1;
    bool have_c1 = false;
    struct dy_core_expr type;
    if (!dy_check_expr(ctx, *inference_type_map.type, &c1, &have_c1, &type)) {
        type = dy_core_expr_retain(*inference_type_map.type);
    }
    
    dy_array_add(&ctx->bindings, &(struct dy_core_binding){
        .id = inference_type_map.id,
        .type = type,
        .is_inference_var = true,
        .polarity = inference_type_map.polarity
    });

    struct dy_constraint c2;
    bool have_c2 = false;
    struct dy_core_expr expr;
    if (!dy_check_expr(ctx, *inference_type_map.expr, &c2, &have_c2, &expr)) {
        expr = dy_core_expr_retain(*inference_type_map.expr);
    }

    --ctx->bindings.num_elems;
    
    struct dy_constraint c3;
    bool have_c3 = false;
    struct dy_core_expr expr2;
    if (resolve_inference_var(ctx, inference_type_map.id, type, inference_type_map.polarity, expr, c2, have_c2, &c3, &have_c3, &expr2)) {
        dy_core_expr_release(expr);
        expr = expr2;
    }
    
    if (have_c2) {
        dy_constraint_release(c2);
    }

    dy_join_constraints(c1, have_c1, DY_CORE_POLARITY_POSITIVE, c3, have_c3, constraint, did_generate_constraint);

    dy_core_expr_release(type);
    
    return expr;
}

void dy_binding_contraints(struct dy_core_ctx *ctx, size_t id, struct dy_constraint constraint, bool have_constraint, dy_array_t *ids)
{
    if (!have_constraint) {
        return;
    }

    switch (constraint.tag) {
    case DY_CONSTRAINT_SINGLE:
        if (constraint.single.id == id) {
            return;
        }

        // No duplicates.
        for (size_t i = 0, size = ids->num_elems; i < size; ++i) {
            size_t binding_id;
            dy_array_get(*ids, i, &binding_id);

            if (constraint.single.id == binding_id) {
                return;
            }
        }

        size_t old_size = ctx->already_visited_ids.num_elems;
        bool is_dependency = dy_is_dependency_of_constraint(ctx, id, constraint.single.id);
        ctx->already_visited_ids.num_elems = old_size;
        if (is_dependency) {
            return;
        }

        if (dy_core_expr_is_bound(id, constraint.single.expr)) {
            dy_array_add(ids, &constraint.single.id);
            return;
        }

        return;
    case DY_CONSTRAINT_MULTIPLE:
        dy_binding_contraints(ctx, id, *constraint.multiple.c1, true, ids);
        dy_binding_contraints(ctx, id, *constraint.multiple.c2, true, ids);
        return;
    }

    dy_bail("Impossible constraint type.");
}

bool dy_is_dependency_of_constraint(struct dy_core_ctx *ctx, size_t potential_dependency_id, size_t current_constraint_id)
{
    dy_array_add(&ctx->already_visited_ids, &current_constraint_id);

    for (size_t i = ctx->bound_constraints.num_elems; i-- > 0;) {
        struct dy_bound_constraint bound_constraint;
        dy_array_get(ctx->bound_constraints, i, &bound_constraint);

        if (current_constraint_id != bound_constraint.id) {
            continue;
        }

        for (size_t k = 0; k < bound_constraint.binding_ids.num_elems; ++k) {
            size_t dependency_of_current_constraint_id;
            dy_array_get(bound_constraint.binding_ids, k, &dependency_of_current_constraint_id);

            if (dependency_of_current_constraint_id == potential_dependency_id) {
                return true;
            }

            bool skip_id = false;
            for (size_t h = 0, size = ctx->already_visited_ids.num_elems; h < size; ++h) {
                size_t already_visited_id;
                dy_array_get(ctx->already_visited_ids, h, &already_visited_id);

                if (already_visited_id == dependency_of_current_constraint_id) {
                    skip_id = true;
                    break;
                }
            }

            if (skip_id) {
                continue;
            }

            if (dy_is_dependency_of_constraint(ctx, potential_dependency_id, dependency_of_current_constraint_id)) {
                return true;
            }
        }

        return false;
    }

    return false;
}

bool dy_free_constraint(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr expr, struct dy_constraint c, bool have_c, struct dy_constraint *c_out, bool *have_c_out, struct dy_core_expr *result)
{
    struct dy_core_expr ret = dy_core_expr_retain(expr);
    
    if (have_c) {
        c = dy_constraint_retain(c);
    }
    
    bool did_transform = false;
    for (size_t i = ctx->bound_constraints.num_elems; i-- > 0;) {
        struct dy_bound_constraint *bound_constraint = dy_array_pos(ctx->bound_constraints, i);

        remove_id(&bound_constraint->binding_ids, id);

        if (bound_constraint->binding_ids.num_elems != 0) {
            continue;
        }

        dy_retire_ids_array(ctx, bound_constraint->binding_ids);
        
        struct dy_bound_constraint copy = *bound_constraint;

        dy_array_remove(&ctx->bound_constraints, i);
        
        struct dy_constraint c2;
        bool have_c2 = false;
        struct dy_core_expr ret2;
        if (resolve_inference_var(ctx, copy.id, copy.type, copy.polarity, ret, c, have_c, &c2, &have_c2, &ret2)) {
            did_transform = true;
            dy_core_expr_release(ret);
            ret = ret2;
        }
        
        if (have_c) {
            dy_constraint_release(c);
        }
        
        c = c2;
        have_c = have_c2;

        i = ctx->bound_constraints.num_elems;
    }
    
    if (have_c) {
        *c_out = c;
        *have_c_out = true;
    }
    
    if (!did_transform) {
        dy_core_expr_release(ret);
        return false;
    } else {
        *result = ret;
        return true;
    }
}

bool resolve_inference_var(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr type, enum dy_core_polarity polarity, struct dy_core_expr expr, struct dy_constraint c_in, bool have_c_in, struct dy_constraint *c_out, bool *have_c_out, struct dy_core_expr *result)
{
    struct dy_core_expr sub;
    bool have_sub = false;
    if (have_c_in) {
        have_sub = dy_constraint_collect(c_in, id, polarity, &sub);
    }

    if (have_sub) {
        if (dy_core_expr_is_bound(id, sub)) {
            sub = (struct dy_core_expr){
                .tag = DY_CORE_EXPR_RECURSION,
                .recursion = {
                    .id = id,
                    .type = dy_core_expr_new(dy_core_expr_retain(type)),
                    .expr = dy_core_expr_new(sub),
                    .polarity = polarity,
                    .check_result = DY_YES
                }
            };
        }

        if (!substitute(ctx, expr, id, sub, &expr)) {
            expr = dy_core_expr_retain(expr);
        }
        
        dy_core_expr_release(sub);

        struct dy_constraint c2;
        bool have_c2 = false;
        struct dy_core_expr new_expr;
        if (dy_check_expr(ctx, expr, &c2, &have_c2, &new_expr)) {
            dy_core_expr_release(expr);
            expr = new_expr;
        }

        if (dy_free_constraint(ctx, id, expr, c2, have_c2, c_out, have_c_out, &new_expr)) {
            dy_core_expr_release(expr);
            expr = new_expr;
        }
        
        if (have_c2) {
            dy_constraint_release(c2);
        }
        
        *result = expr;
        return true;
    } else {
        dy_array_t ids = dy_new_ids_array(ctx);
        dy_binding_contraints(ctx, id, c_in, have_c_in, &ids);

        if (ids.num_elems == 0) {
            dy_retire_ids_array(ctx, ids);

            struct dy_core_expr type_of_expr = dy_type_of(ctx, expr);
            bool appears_in_positive_position = false;
            bool appears_in_negative_position = false;

            dy_core_appears_in_polarity(id, type_of_expr, DY_CORE_POLARITY_POSITIVE, &appears_in_positive_position, &appears_in_negative_position);

            if (appears_in_positive_position && appears_in_negative_position) {
                expr = (struct dy_core_expr){
                    .tag = DY_CORE_EXPR_TYPE_MAP,
                    .type_map = {
                        .id = id,
                        .type = dy_core_expr_new(dy_core_expr_retain(type)),
                        .polarity = DY_CORE_POLARITY_POSITIVE,
                        .expr = dy_core_expr_new(dy_core_expr_retain(expr)),
                        .is_implicit = true,
                    }
                };
            } else {
                struct dy_core_expr end = {
                    .tag = DY_CORE_EXPR_END,
                    .end_polarity = polarity
                };

                if (!substitute(ctx, expr, id, end, &expr)) {
                    expr = dy_core_expr_retain(expr);
                }
            }

            dy_core_expr_release(type_of_expr);

            struct dy_core_expr new_expr;
            if (dy_free_constraint(ctx, id, expr, c_in, have_c_in, c_out, have_c_out, &new_expr)) {
                dy_core_expr_release(expr);
                expr = new_expr;
            }
            
            *result = expr;
            return true;
        } else {
            struct dy_bound_constraint bound_constraint = {
                .id = id,
                .type = dy_core_expr_retain(type),
                .polarity = flip_polarity(polarity),
                .binding_ids = ids,
            };

            dy_array_add(&ctx->bound_constraints, &bound_constraint);
            
            if (have_c_in) {
                *c_out = dy_constraint_retain(c_in);
                *have_c_out = true;
            }

            return false;
        }
    }
}

void remove_id(dy_array_t *ids, size_t id_to_remove)
{
    for (size_t i = 0, size = ids->num_elems; i < size; ++i) {
        size_t id;
        dy_array_get(*ids, i, &id);

        if (id == id_to_remove) {
            dy_array_remove(ids, i);
            return;
        }
    }
}

bool remove_mentions_in_constraint(struct dy_core_ctx *ctx, size_t id, struct dy_constraint constraint, struct dy_constraint *result)
{
    switch (constraint.tag) {
    case DY_CONSTRAINT_SINGLE:
        switch (constraint.single.polarity) {
        case DY_CORE_POLARITY_POSITIVE:
            if (remove_mentions_in_subtype(ctx, id, constraint.single.expr, &constraint.single.expr)) {
                *result = constraint;
                return true;
            } else {
                return false;
            }
        case DY_CORE_POLARITY_NEGATIVE:
            if (remove_mentions_in_supertype(ctx, id, constraint.single.expr, &constraint.single.expr)) {
                *result = constraint;
                return true;
            } else {
                return false;
            }
        }

        dy_bail("Impossible polarity");
    case DY_CONSTRAINT_MULTIPLE: {
        struct dy_constraint c1;
        bool c1_is_new = remove_mentions_in_constraint(ctx, id, *constraint.multiple.c1, &c1);
        
        struct dy_constraint c2;
        bool c2_is_new = remove_mentions_in_constraint(ctx, id, *constraint.multiple.c2, &c2);
        
        if (!c1_is_new && !c2_is_new) {
            return false;
        }
        
        if (c1_is_new) {
            constraint.multiple.c1 = dy_constraint_new(c1);
        } else {
            dy_constraint_retain_ptr(constraint.multiple.c1);
        }
        
        if (c2_is_new) {
            constraint.multiple.c2 = dy_constraint_new(c2);
        } else {
            dy_constraint_retain_ptr(constraint.multiple.c2);
        }
        
        *result = constraint;
        return true;
    }
    }

    dy_bail("Impossible constraint type");
}

bool remove_mentions_in_subtype(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr subtype, struct dy_core_expr *result)
{
    switch (subtype.tag) {
    case DY_CORE_EXPR_EQUALITY_MAP: {
        if (dy_core_expr_is_bound(id, *subtype.equality_map.e1)) {
            if (subtype.equality_map.polarity == DY_CORE_POLARITY_NEGATIVE) {
                *result = (struct dy_core_expr){
                    .tag = DY_CORE_EXPR_END,
                    .end_polarity = DY_CORE_POLARITY_POSITIVE
                };
                return true;
            } else {
                struct dy_core_expr type_map = {
                    .tag = DY_CORE_EXPR_TYPE_MAP,
                    .type_map = {
                        .id = ctx->running_id++,
                        .type = dy_core_expr_new(dy_type_of(ctx, *subtype.equality_map.e1)),
                        .expr = dy_core_expr_retain_ptr(subtype.equality_map.e2),
                        .polarity = DY_CORE_POLARITY_NEGATIVE,
                        .is_implicit = subtype.equality_map.is_implicit,
                    }
                };

                if (remove_mentions_in_subtype(ctx, id, type_map, result)) {
                    dy_core_expr_release(type_map);
                } else {
                    *result = type_map;
                }

                return true;
            }
        }
        
        struct dy_core_expr e2;
        if (!remove_mentions_in_subtype(ctx, id, *subtype.equality_map.e2, &e2)) {
            return false;
        }
        
        dy_core_expr_retain_ptr(subtype.equality_map.e1);
        subtype.equality_map.e2 = dy_core_expr_new(e2);
        *result = subtype;
        return true;
    }
    case DY_CORE_EXPR_TYPE_MAP: {
        struct dy_core_expr type;
        bool type_is_new = remove_mentions_in_supertype(ctx, id, *subtype.type_map.type, &type);
        
        struct dy_core_expr expr;
        bool expr_is_new = remove_mentions_in_subtype(ctx, id, *subtype.type_map.expr, &expr);
        
        if (!type_is_new && !expr_is_new) {
            return false;
        }
        
        if (type_is_new) {
            subtype.type_map.type = dy_core_expr_new(type);
        } else {
            dy_core_expr_retain_ptr(subtype.type_map.type);
        }
        
        if (expr_is_new) {
            subtype.type_map.expr = dy_core_expr_new(expr);
        } else {
            dy_core_expr_retain_ptr(subtype.type_map.expr);
        }
        
        *result = subtype;
        return true;
    }
    case DY_CORE_EXPR_INFERENCE_TYPE_MAP: {
        struct dy_core_expr type;
        bool type_is_new = remove_mentions_in_supertype(ctx, id, *subtype.inference_type_map.type, &type);
        
        struct dy_core_expr expr;
        bool expr_is_new = remove_mentions_in_subtype(ctx, id, *subtype.inference_type_map.expr, &expr);
        
        if (!type_is_new && !expr_is_new) {
            return false;
        }
        
        if (type_is_new) {
            subtype.inference_type_map.type = dy_core_expr_new(type);
        } else {
            dy_core_expr_retain_ptr(subtype.inference_type_map.type);
        }
        
        if (expr_is_new) {
            subtype.inference_type_map.expr = dy_core_expr_new(expr);
        } else {
            dy_core_expr_retain_ptr(subtype.inference_type_map.expr);
        }
        
        *result = subtype;
        return true;
    }
    case DY_CORE_EXPR_EQUALITY_MAP_ELIM:
        // fallthrough
    case DY_CORE_EXPR_ALTERNATIVE:
        // fallthrough
    case DY_CORE_EXPR_TYPE_MAP_ELIM:
        if (dy_core_expr_is_bound(id, subtype)) {
            *result = (struct dy_core_expr){
                .tag = DY_CORE_EXPR_END,
                .end_polarity = DY_CORE_POLARITY_POSITIVE
            };
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_JUNCTION: {
        struct dy_core_expr e1;
        bool e1_is_new = remove_mentions_in_subtype(ctx, id, *subtype.junction.e1, &e1);
           
        struct dy_core_expr e2;
        bool e2_is_new = remove_mentions_in_subtype(ctx, id, *subtype.junction.e2, &e2);
           
       if (!e1_is_new && !e2_is_new) {
           return false;
       }
       
       if (e1_is_new) {
           subtype.junction.e1 = dy_core_expr_new(e1);
       } else {
           dy_core_expr_retain_ptr(subtype.junction.e1);
       }
       
       if (e2_is_new) {
           subtype.junction.e2 = dy_core_expr_new(e2);
       } else {
           dy_core_expr_retain_ptr(subtype.junction.e2);
       }
       
       *result = subtype;
       return true;
    }
    case DY_CORE_EXPR_RECURSION: {
        struct dy_core_expr type;
        bool type_is_new = remove_mentions_in_supertype(ctx, id, *subtype.recursion.type, &type);
        
        struct dy_core_expr expr;
        bool expr_is_new = remove_mentions_in_subtype(ctx, id, *subtype.recursion.expr, &expr);
        
        if (!type_is_new && !expr_is_new) {
            return false;
        }
        
        if (type_is_new) {
            subtype.recursion.type = dy_core_expr_new(type);
        } else {
            dy_core_expr_retain_ptr(subtype.recursion.type);
        }
        
        if (expr_is_new) {
            subtype.recursion.expr = dy_core_expr_new(expr);
        } else {
            dy_core_expr_retain_ptr(subtype.recursion.expr);
        }
        
        *result = subtype;
        return true;
    }
    case DY_CORE_EXPR_VARIABLE:
        if (subtype.variable_id == id) {
            *result = (struct dy_core_expr){
                .tag = DY_CORE_EXPR_END,
                .end_polarity = DY_CORE_POLARITY_POSITIVE
            };
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_CUSTOM:
        return subtype.custom.remove_mentions_in_subtype(subtype.custom.data, ctx, id, result);
    case DY_CORE_EXPR_END:
    case DY_CORE_EXPR_SYMBOL:
        return false;
    }

    dy_bail("Impossible object type.");
}

bool remove_mentions_in_supertype(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr supertype, struct dy_core_expr *result)
{
    switch (supertype.tag) {
    case DY_CORE_EXPR_EQUALITY_MAP: {
        if (dy_core_expr_is_bound(id, *supertype.equality_map.e1)) {
            if (supertype.equality_map.polarity == DY_CORE_POLARITY_POSITIVE) {
                *result = (struct dy_core_expr){
                    .tag = DY_CORE_EXPR_END,
                    .end_polarity = DY_CORE_POLARITY_NEGATIVE
                };
                return true;
            } else {
                struct dy_core_expr type_map = {
                    .tag = DY_CORE_EXPR_TYPE_MAP,
                    .type_map = {
                        .id = ctx->running_id++,
                        .type = dy_core_expr_new(dy_type_of(ctx, *supertype.equality_map.e1)),
                        .expr = dy_core_expr_retain_ptr(supertype.equality_map.e2),
                        .polarity = DY_CORE_POLARITY_POSITIVE,
                        .is_implicit = supertype.equality_map.is_implicit,
                    }
                };

                if (remove_mentions_in_supertype(ctx, id, type_map, result)) {
                    dy_core_expr_release(type_map);
                } else {
                    *result = type_map;
                }

                return true;
            }
        }
        
        struct dy_core_expr e2;
        if (!remove_mentions_in_supertype(ctx, id, *supertype.equality_map.e2, &e2)) {
            return false;
        }
        
        dy_core_expr_retain_ptr(supertype.equality_map.e1);
        supertype.equality_map.e2 = dy_core_expr_new(e2);
        *result = supertype;
        return true;
    }
    case DY_CORE_EXPR_TYPE_MAP: {
        struct dy_core_expr type;
        bool type_is_new = remove_mentions_in_subtype(ctx, id, *supertype.type_map.type, &type);
        
        struct dy_core_expr expr;
        bool expr_is_new = remove_mentions_in_supertype(ctx, id, *supertype.type_map.expr, &expr);
        
        if (!type_is_new && !expr_is_new) {
            return false;
        }
        
        if (type_is_new) {
            supertype.type_map.type = dy_core_expr_new(type);
        } else {
            dy_core_expr_retain_ptr(supertype.type_map.type);
        }
        
        if (expr_is_new) {
            supertype.type_map.expr = dy_core_expr_new(expr);
        } else {
            dy_core_expr_retain_ptr(supertype.type_map.expr);
        }
        
        *result = supertype;
        return true;
    }
    case DY_CORE_EXPR_INFERENCE_TYPE_MAP: {
        struct dy_core_expr type;
        bool type_is_new = remove_mentions_in_subtype(ctx, id, *supertype.inference_type_map.type, &type);
        
        struct dy_core_expr expr;
        bool expr_is_new = remove_mentions_in_supertype(ctx, id, *supertype.inference_type_map.expr, &expr);
        
        if (!type_is_new && !expr_is_new) {
            return false;
        }
        
        if (type_is_new) {
            supertype.inference_type_map.type = dy_core_expr_new(type);
        } else {
            dy_core_expr_retain_ptr(supertype.inference_type_map.type);
        }
        
        if (expr_is_new) {
            supertype.inference_type_map.expr = dy_core_expr_new(expr);
        } else {
            dy_core_expr_retain_ptr(supertype.inference_type_map.expr);
        }
        
        *result = supertype;
        return true;
    }
    case DY_CORE_EXPR_EQUALITY_MAP_ELIM:
        // fallthrough
    case DY_CORE_EXPR_ALTERNATIVE:
        // fallthrough
    case DY_CORE_EXPR_TYPE_MAP_ELIM:
        if (dy_core_expr_is_bound(id, supertype)) {
            *result = (struct dy_core_expr){
                .tag = DY_CORE_EXPR_END,
                .end_polarity = DY_CORE_POLARITY_NEGATIVE
            };
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_JUNCTION: {
        struct dy_core_expr e1;
        bool e1_is_new = remove_mentions_in_supertype(ctx, id, *supertype.junction.e1, &e1);
           
        struct dy_core_expr e2;
        bool e2_is_new = remove_mentions_in_supertype(ctx, id, *supertype.junction.e2, &e2);
           
       if (!e1_is_new && !e2_is_new) {
           return false;
       }
       
       if (e1_is_new) {
           supertype.junction.e1 = dy_core_expr_new(e1);
       } else {
           dy_core_expr_retain_ptr(supertype.junction.e1);
       }
       
       if (e2_is_new) {
           supertype.junction.e2 = dy_core_expr_new(e2);
       } else {
           dy_core_expr_retain_ptr(supertype.junction.e2);
       }
       
       *result = supertype;
       return true;
    }
    case DY_CORE_EXPR_RECURSION: {
        struct dy_core_expr type;
        bool type_is_new = remove_mentions_in_subtype(ctx, id, *supertype.recursion.type, &type);
        
        struct dy_core_expr expr;
        bool expr_is_new = remove_mentions_in_supertype(ctx, id, *supertype.recursion.expr, &expr);
        
        if (!type_is_new && !expr_is_new) {
            return false;
        }
        
        if (type_is_new) {
            supertype.recursion.type = dy_core_expr_new(type);
        } else {
            dy_core_expr_retain_ptr(supertype.recursion.type);
        }
        
        if (expr_is_new) {
            supertype.recursion.expr = dy_core_expr_new(expr);
        } else {
            dy_core_expr_retain_ptr(supertype.recursion.expr);
        }
        
        *result = supertype;
        return true;
    }
    case DY_CORE_EXPR_VARIABLE:
        if (supertype.variable_id == id) {
            *result = (struct dy_core_expr){
                .tag = DY_CORE_EXPR_END,
                .end_polarity = DY_CORE_POLARITY_NEGATIVE
            };
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_CUSTOM:
        return supertype.custom.remove_mentions_in_supertype(supertype.custom.data, ctx, id, result);
    case DY_CORE_EXPR_END:
    case DY_CORE_EXPR_SYMBOL:
        return false;
    }

    dy_bail("Impossible object type.");
}

void dy_join_constraints3(struct dy_constraint c1, bool have_c1, struct dy_constraint c2, bool have_c2, struct dy_constraint c3, bool have_c3, struct dy_constraint *c4, bool *have_c4)
{
    struct dy_constraint c5;
    bool have_c5 = false;
    dy_join_constraints(c1, have_c1, DY_CORE_POLARITY_POSITIVE, c2, have_c2, &c5, &have_c5);
    
    dy_join_constraints(c3, have_c3, DY_CORE_POLARITY_POSITIVE, c5, have_c5, c4, have_c4);
}

dy_array_t dy_new_ids_array(struct dy_core_ctx *ctx)
{
    if (ctx->free_ids_arrays.num_elems == 0) {
        return dy_array_create(sizeof(size_t), DY_ALIGNOF(size_t), 4);
    } else {
        dy_array_t x;
        dy_array_pop(&ctx->free_ids_arrays, &x);
        return x;
    }
}

void dy_retire_ids_array(struct dy_core_ctx *ctx, dy_array_t array)
{
    dy_array_add(&ctx->free_ids_arrays, &array);
}
