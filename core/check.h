/*
 * Copyright 2017-2020 Thorben Hasenpusch <t.hasenpusch@icloud.com>
 *
 * SPDX-License-Identifier: MIT
 */

#pragma once

#include "constraint.h"
#include "core.h"
#include "type_of.h"
#include "is_subtype.h"

#include "../support/bail.h"

/**
 * The functions here define the 'check' procedure for each object of Core.
 *
 * It has three purposes:
 *   (1) Update the subtype result of every elimination & recursion if needed.
 *   (2) Collect the constraints generated by (1).
 *   (3) Resolve inference contexts using the constraints of (2).
 *
 *  'check' is build as a pipeline:
 *   Expression comes in, validated & transformed expression + constraints come out.
 */

static inline bool dy_check_expr(struct dy_core_ctx *ctx, struct dy_core_expr expr, struct dy_core_expr *result);

static inline bool dy_check_equality_map(struct dy_core_ctx *ctx, struct dy_core_equality_map equality_map, struct dy_core_equality_map *result);

static inline bool dy_check_type_map(struct dy_core_ctx *ctx, struct dy_core_type_map type_map, struct dy_core_type_map *result);

static inline bool dy_check_equality_map_elim(struct dy_core_ctx *ctx, struct dy_core_equality_map_elim elim, struct dy_core_expr *result);

static inline bool dy_check_type_map_elim(struct dy_core_ctx *ctx, struct dy_core_type_map_elim elim, struct dy_core_expr *result);

static inline bool dy_check_junction(struct dy_core_ctx *ctx, struct dy_core_junction junction, struct dy_core_junction *result);

static inline bool dy_check_alternative(struct dy_core_ctx *ctx, struct dy_core_alternative alternative, struct dy_core_alternative *result);

static inline struct dy_core_expr dy_check_inference_type_map(struct dy_core_ctx *ctx, struct dy_core_inference_type_map inference_type_map);

static inline bool dy_check_recursion(struct dy_core_ctx *ctx, struct dy_core_recursion recursion, struct dy_core_expr *result);

/**
 * Collects the id of every constraint that mentions 'id'.
 * If the size of 'ids' isn't changed upon returning, 'id' is "free" and can be resolved.
 */
static inline void dy_collect_binding_inference_vars(struct dy_core_ctx *ctx, size_t id, size_t constraint_start, dy_array_t *ids);

static inline bool dy_is_dependency_of_constraint(struct dy_core_ctx *ctx, size_t potential_dependency_id, size_t current_constraint_id);

static inline bool dy_resolve_now_free_inference_vars(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr expr, size_t constraint_start, struct dy_core_expr *result);

static inline bool dy_resolve_inference_var(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr type, enum dy_core_polarity polarity, struct dy_core_expr expr, size_t constraint_start, struct dy_core_expr *result);

/**
 * Just removes 'id' from 'ids', if present.
 */
static inline void remove_id(dy_array_t *ids, size_t id);

/**
 * Removes all mentions of 'id' in 'constraint', which may involve lowering/raising the subtype/supertype bounds.
 */
static inline void remove_mentions_in_constraints(struct dy_core_ctx *ctx, size_t id, size_t start);

/**
 * Removes all mentions of 'id'. The returned type is always a supertype of 'subtype'.
 */
static inline bool remove_mentions_in_subtype(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr subtype, struct dy_core_expr *result);

/**
 * Removes all mentions of 'id'. The returned type is always a subtype of 'supertype'.
 */
static inline bool remove_mentions_in_supertype(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr supertype, struct dy_core_expr *result);

static inline dy_array_t dy_new_ids_array(struct dy_core_ctx *ctx);

static inline void dy_retire_ids_array(struct dy_core_ctx *ctx, dy_array_t array);

bool dy_check_expr(struct dy_core_ctx *ctx, struct dy_core_expr expr, struct dy_core_expr *result)
{
    switch (expr.tag) {
    case DY_CORE_EXPR_EQUALITY_MAP:
        if (dy_check_equality_map(ctx, expr.equality_map, &expr.equality_map)) {
            *result = expr;
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_TYPE_MAP:
        if (dy_check_type_map(ctx, expr.type_map, &expr.type_map)) {
            *result = expr;
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_EQUALITY_MAP_ELIM:
        if (dy_check_equality_map_elim(ctx, expr.equality_map_elim, &expr)) {
            *result = expr;
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_TYPE_MAP_ELIM:
        if (dy_check_type_map_elim(ctx, expr.type_map_elim, &expr)) {
            *result = expr;
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_JUNCTION:
        if (dy_check_junction(ctx, expr.junction, &expr.junction)) {
            *result = expr;
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_RECURSION:
        if (dy_check_recursion(ctx, expr.recursion, &expr)) {
            *result = expr;
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_ALTERNATIVE:
        if (dy_check_alternative(ctx, expr.alternative, &expr.alternative)) {
            *result = expr;
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_INFERENCE_TYPE_MAP:
        *result = dy_check_inference_type_map(ctx, expr.inference_type_map);
        return true;
    case DY_CORE_EXPR_VARIABLE:
        return false;
    case DY_CORE_EXPR_END:
        return false;
    case DY_CORE_EXPR_CUSTOM: {
        const struct dy_core_custom_shared *s = dy_array_pos(ctx->custom_shared, expr.custom.id);
        return s->check(expr.custom.data, ctx, result);
    }
    case DY_CORE_EXPR_SYMBOL:
        return false;
    }

    dy_bail("Impossible object type.");
}

bool dy_check_equality_map(struct dy_core_ctx *ctx, struct dy_core_equality_map equality_map, struct dy_core_equality_map *result)
{
    size_t constraint_start1 = ctx->constraints.num_elems;
    struct dy_core_expr e1;
    bool e1_is_new = dy_check_expr(ctx, *equality_map.e1, &e1);

    size_t constraint_start2 = ctx->constraints.num_elems;
    struct dy_core_expr e2;
    bool e2_is_new = dy_check_expr(ctx, *equality_map.e2, &e2);
    
    dy_join_constraints(ctx, constraint_start1, constraint_start2, DY_CORE_POLARITY_POSITIVE);

    if (!e1_is_new && !e2_is_new) {
        return false;
    }
    
    if (e1_is_new) {
        equality_map.e1 = dy_core_expr_new(e1);
    } else {
        dy_core_expr_retain_ptr(equality_map.e1);
    }
    
    if (e2_is_new) {
        equality_map.e2 = dy_core_expr_new(e2);
    } else {
        dy_core_expr_retain_ptr(equality_map.e2);
    }
    
    *result = equality_map;
    return true;
}

bool dy_check_type_map(struct dy_core_ctx *ctx, struct dy_core_type_map type_map, struct dy_core_type_map *result)
{
    size_t constraint_start1 = ctx->constraints.num_elems;
    struct dy_core_expr type;
    bool type_is_new = dy_check_expr(ctx, *type_map.type, &type);
    if (!type_is_new) {
        type = dy_core_expr_retain(ctx, *type_map.type);
    }

    dy_array_add(&ctx->bindings, &(struct dy_core_binding){
        .id = type_map.id,
        .type = type,
        .is_inference_var = false
    });

    size_t constraint_start2 = ctx->constraints.num_elems;
    struct dy_core_expr expr;
    bool expr_is_new = dy_check_expr(ctx, *type_map.expr, &expr);

    remove_mentions_in_constraints(ctx, type_map.id, constraint_start2);

    --ctx->bindings.num_elems;

    dy_join_constraints(ctx, constraint_start1, constraint_start2, DY_CORE_POLARITY_POSITIVE);
    
    if (!type_is_new && !expr_is_new) {
        dy_core_expr_release(ctx, type);
        return false;
    }
    
    if (type_is_new) {
        type_map.type = dy_core_expr_new(type);
    } else {
        dy_core_expr_release(ctx, type);
        dy_core_expr_retain_ptr(type_map.type);
    }
    
    if (expr_is_new) {
        type_map.expr = dy_core_expr_new(expr);
    } else {
        dy_core_expr_retain_ptr(type_map.expr);
    }

    *result = type_map;
    return true;
}

bool dy_check_equality_map_elim(struct dy_core_ctx *ctx, struct dy_core_equality_map_elim elim, struct dy_core_expr *result)
{
    size_t constraint_start1 = ctx->constraints.num_elems;
    struct dy_core_expr expr;
    bool expr_is_new = dy_check_expr(ctx, *elim.expr, &expr);
    if (!expr_is_new) {
        expr = dy_core_expr_retain(ctx, *elim.expr);
    }

    size_t constraint_start2 = ctx->constraints.num_elems;
    struct dy_core_equality_map eq_map;
    bool eq_map_is_new = dy_check_equality_map(ctx, elim.map, &eq_map);
    if (!eq_map_is_new) {
        eq_map = elim.map;
        dy_core_expr_retain_ptr(eq_map.e1);
        dy_core_expr_retain_ptr(eq_map.e2);
    }

    dy_join_constraints(ctx, constraint_start1, constraint_start2, DY_CORE_POLARITY_POSITIVE);
    
    size_t subtype_implicits_old_size = ctx->subtype_implicits.num_elems;

    dy_ternary_t check_result = elim.check_result;
    if (check_result == DY_MAYBE) {
        struct dy_core_expr type_of_expr = dy_type_of(ctx, expr);

        constraint_start2 = ctx->constraints.num_elems;

        if (dy_core_expr_is_computation(ctx, *eq_map.e1)) {
            struct dy_core_expr type_of_equality_map_e1 = dy_type_of(ctx, *eq_map.e1);

            struct dy_core_expr type_map_expr = {
                .tag = DY_CORE_EXPR_TYPE_MAP,
                .type_map = {
                    .id = ctx->running_id++,
                    .type = dy_core_expr_new(type_of_equality_map_e1),
                    .expr = dy_core_expr_retain_ptr(eq_map.e2),
                    .polarity = DY_CORE_POLARITY_POSITIVE,
                    .is_implicit = eq_map.is_implicit,
                }
            };
            
            bool did_transform_expr = false;
            struct dy_core_expr new_expr;
            check_result = dy_is_subtype(ctx, type_of_expr, type_map_expr, expr, &new_expr, &did_transform_expr);
            if (did_transform_expr) {
                expr_is_new = true;
                dy_core_expr_release(ctx, expr);
                expr = new_expr;
            }

            dy_core_expr_release(ctx, type_map_expr);
        } else {
            struct dy_core_expr equality_map_expr = {
                .tag = DY_CORE_EXPR_EQUALITY_MAP,
                .equality_map = eq_map
            };
            
            bool did_transform_expr = false;
            struct dy_core_expr new_expr;
            check_result = dy_is_subtype(ctx, type_of_expr, equality_map_expr, expr, &new_expr, &did_transform_expr);
            if (did_transform_expr) {
                expr_is_new = true;
                dy_core_expr_release(ctx, expr);
                expr = new_expr;
            }
        }

        dy_join_constraints(ctx, constraint_start1, constraint_start2, DY_CORE_POLARITY_POSITIVE);

        dy_core_expr_release(ctx, type_of_expr);
    }
    
    if (expr_is_new) {
        elim.expr = dy_core_expr_new(expr);
    } else {
        dy_core_expr_release(ctx, expr);
        dy_core_expr_retain_ptr(elim.expr);
    }
    
    if (eq_map_is_new) {
        elim.map = eq_map;
    } else {
        dy_core_expr_release_ptr(ctx, eq_map.e1);
        dy_core_expr_release_ptr(ctx, eq_map.e2);
        dy_core_expr_retain_ptr(elim.map.e1);
        dy_core_expr_retain_ptr(elim.map.e2);
    }
    
    dy_ternary_t old_status = elim.check_result;
    elim.check_result = check_result;

    struct dy_core_expr ret = {
        .tag = DY_CORE_EXPR_EQUALITY_MAP_ELIM,
        .equality_map_elim = elim
    };

    bool transformed = false;
    for (size_t i = subtype_implicits_old_size, size = ctx->subtype_implicits.num_elems; i < size; ++i) {
        struct dy_core_binding b;
        dy_array_pop(&ctx->subtype_implicits, &b);

        struct dy_core_expr ret2;
        if (dy_resolve_inference_var(ctx, b.id, b.type, DY_CORE_POLARITY_NEGATIVE, ret, constraint_start1, &ret2)) {
            transformed = true;
            dy_core_expr_release(ctx, ret);
            ret = ret2;
        }
    }
    
    if (!expr_is_new && !eq_map_is_new && elim.check_result == old_status && !transformed) {
        dy_core_expr_release(ctx, ret);
        return false;
    } else {
        *result = ret;
        return true;
    }
}

bool dy_check_type_map_elim(struct dy_core_ctx *ctx, struct dy_core_type_map_elim elim, struct dy_core_expr *result)
{
    dy_bail("Not yet implemented.");
}

bool dy_check_junction(struct dy_core_ctx *ctx, struct dy_core_junction junction, struct dy_core_junction *result)
{
    size_t constraint_start1 = ctx->constraints.num_elems;
    struct dy_core_expr e1;
    bool e1_is_new = dy_check_expr(ctx, *junction.e1, &e1);

    size_t constraint_start2 = ctx->constraints.num_elems;
    struct dy_core_expr e2;
    bool e2_is_new = dy_check_expr(ctx, *junction.e2, &e2);

    dy_join_constraints(ctx, constraint_start1, constraint_start2, DY_CORE_POLARITY_POSITIVE);
    
    if (!e1_is_new && !e2_is_new) {
        return false;
    }
    
    if (e1_is_new) {
        junction.e1 = dy_core_expr_new(e1);
    } else {
        dy_core_expr_retain_ptr(junction.e1);
    }
    
    if (e2_is_new) {
        junction.e2 = dy_core_expr_new(e2);
    } else {
        dy_core_expr_retain_ptr(junction.e2);
    }

    *result = junction;
    return true;
}

bool dy_check_alternative(struct dy_core_ctx *ctx, struct dy_core_alternative alternative, struct dy_core_alternative *result)
{
    size_t constraint_start1 = ctx->constraints.num_elems;
    struct dy_core_expr first;
    bool first_is_new = dy_check_expr(ctx, *alternative.first, &first);

    size_t constraint_start2 = ctx->constraints.num_elems;
    struct dy_core_expr second;
    bool second_is_new = dy_check_expr(ctx, *alternative.second, &second);

    dy_join_constraints(ctx, constraint_start1, constraint_start2, DY_CORE_POLARITY_NEGATIVE);
    
    if (!first_is_new && !second_is_new) {
        return false;
    }
    
    if (first_is_new) {
        alternative.first = dy_core_expr_new(first);
    } else {
        dy_core_expr_retain_ptr(alternative.first);
    }
    
    if (second_is_new) {
        alternative.second = dy_core_expr_new(second);
    } else {
        dy_core_expr_retain_ptr(alternative.second);
    }

    *result = alternative;
    return true;
}

bool dy_check_recursion(struct dy_core_ctx *ctx, struct dy_core_recursion recursion, struct dy_core_expr *result)
{
    size_t constraint_start1 = ctx->constraints.num_elems;
    struct dy_core_expr type;
    bool type_is_new = dy_check_expr(ctx, *recursion.type, &type);
    if (!type_is_new) {
        type = dy_core_expr_retain(ctx, *recursion.type);
    }

    dy_array_add(&ctx->bindings, &(struct dy_core_binding){
        .id = recursion.id,
        .type = type,
        .is_inference_var = false
    });

    size_t constraint_start2 = ctx->constraints.num_elems;
    struct dy_core_expr expr;
    bool expr_is_new = dy_check_expr(ctx, *recursion.expr, &expr);
    if (!expr_is_new) {
        expr = dy_core_expr_retain(ctx, *recursion.expr);
    }

    remove_mentions_in_constraints(ctx, recursion.id, constraint_start2);

    --ctx->bindings.num_elems;
    
    dy_join_constraints(ctx, constraint_start1, constraint_start2, DY_CORE_POLARITY_POSITIVE);
    
    size_t subtype_implicits_old_size = ctx->subtype_implicits.num_elems;

    dy_ternary_t check_result = recursion.check_result;
    if (check_result == DY_MAYBE) {
        struct dy_core_expr type_of_expr = dy_type_of(ctx, expr);

        constraint_start2 = ctx->constraints.num_elems;
        
        struct dy_core_expr expr2;
        bool did_transform_expr = false;
        check_result = dy_is_subtype(ctx, type_of_expr, type, expr, &expr2, &did_transform_expr);
        if (did_transform_expr) {
            expr_is_new = true;
            dy_core_expr_release(ctx, expr);
            expr = expr2;
        }

        dy_join_constraints(ctx, constraint_start1, constraint_start2, DY_CORE_POLARITY_POSITIVE);

        dy_core_expr_release(ctx, type_of_expr);
    }
    
    if (type_is_new) {
        recursion.type = dy_core_expr_new(type);
    } else {
        dy_core_expr_release(ctx, type);
        dy_core_expr_retain_ptr(recursion.type);
    }
    
    if (expr_is_new) {
        recursion.expr = dy_core_expr_new(expr);
    } else {
        dy_core_expr_release(ctx, expr);
        dy_core_expr_retain_ptr(recursion.expr);
    }
    
    dy_ternary_t old_status = recursion.check_result;
    recursion.check_result = check_result;
    
    struct dy_core_expr ret = {
        .tag = DY_CORE_EXPR_RECURSION,
        .recursion = recursion
    };
    
    bool did_transform = false;
    for (size_t i = subtype_implicits_old_size, size = ctx->subtype_implicits.num_elems; i < size; ++i) {
        struct dy_core_binding b;
        dy_array_pop(&ctx->subtype_implicits, &b);

        struct dy_core_expr ret2;
        if (dy_resolve_inference_var(ctx, b.id, b.type, DY_CORE_POLARITY_NEGATIVE, ret, constraint_start1, &ret2)) {
            did_transform = true;
            dy_core_expr_release(ctx, ret);
            ret = ret2;
        }
    }
    
    if (!type_is_new && !expr_is_new && recursion.check_result == old_status && !did_transform) {
        dy_core_expr_release(ctx, ret);
        return false;
    } else {
        *result = ret;
        return true;
    }
}

struct dy_core_expr dy_check_inference_type_map(struct dy_core_ctx *ctx, struct dy_core_inference_type_map inference_type_map)
{
    size_t constraint_start1 = ctx->constraints.num_elems;
    struct dy_core_expr type;
    if (!dy_check_expr(ctx, *inference_type_map.type, &type)) {
        type = dy_core_expr_retain(ctx, *inference_type_map.type);
    }
    
    dy_array_add(&ctx->bindings, &(struct dy_core_binding){
        .id = inference_type_map.id,
        .type = type,
        .is_inference_var = true,
        .polarity = inference_type_map.polarity
    });

    size_t constraint_start2 = ctx->constraints.num_elems;
    struct dy_core_expr expr;
    if (!dy_check_expr(ctx, *inference_type_map.expr, &expr)) {
        expr = dy_core_expr_retain(ctx, *inference_type_map.expr);
    }

    --ctx->bindings.num_elems;

    dy_join_constraints(ctx, constraint_start1, constraint_start2, DY_CORE_POLARITY_POSITIVE);

    struct dy_core_expr expr2;
    if (dy_resolve_inference_var(ctx, inference_type_map.id, type, inference_type_map.polarity, expr, constraint_start1, &expr2)) {
        dy_core_expr_release(ctx, expr);
        expr = expr2;
    }

    dy_core_expr_release(ctx, type);
    
    return expr;
}

void dy_collect_binding_inference_vars(struct dy_core_ctx *ctx, size_t id, size_t constraint_start, dy_array_t *ids)
{
    for (size_t i = constraint_start, size = ctx->constraints.num_elems; i < size; ++i) {
        const struct dy_constraint *c = dy_array_pos(ctx->constraints, i);
        if (c->id == id) {
            continue;
        }

        bool duplicate = false;
        for (size_t k = 0, size2 = ids->num_elems; k < size2; ++k) {
            if (c->id == *(const size_t *)dy_array_pos(*ids, k)) {
                duplicate = true;
                break;
            }
        }
        if (duplicate) {
            continue;
        }

        size_t old_size = ctx->already_visited_ids.num_elems;
        bool is_dependency = dy_is_dependency_of_constraint(ctx, id, c->id);
        ctx->already_visited_ids.num_elems = old_size;
        if (is_dependency) {
            continue;
        }

        if (dy_core_expr_is_bound(ctx, id, c->expr)) {
            dy_array_add(ids, &c->id);
        }
    }
}

bool dy_is_dependency_of_constraint(struct dy_core_ctx *ctx, size_t potential_dependency_id, size_t current_constraint_id)
{
    dy_array_add(&ctx->already_visited_ids, &current_constraint_id);

    for (size_t i = ctx->bound_inference_vars.num_elems; i-- > 0;) {
        struct dy_bound_inference_var bound_inference_var;
        dy_array_get(ctx->bound_inference_vars, i, &bound_inference_var);

        if (current_constraint_id != bound_inference_var.id) {
            continue;
        }

        for (size_t k = 0; k < bound_inference_var.binding_ids.num_elems; ++k) {
            size_t dependency_of_current_constraint_id;
            dy_array_get(bound_inference_var.binding_ids, k, &dependency_of_current_constraint_id);

            if (dependency_of_current_constraint_id == potential_dependency_id) {
                return true;
            }

            bool skip_id = false;
            for (size_t h = 0, size = ctx->already_visited_ids.num_elems; h < size; ++h) {
                size_t already_visited_id;
                dy_array_get(ctx->already_visited_ids, h, &already_visited_id);

                if (already_visited_id == dependency_of_current_constraint_id) {
                    skip_id = true;
                    break;
                }
            }

            if (skip_id) {
                continue;
            }

            if (dy_is_dependency_of_constraint(ctx, potential_dependency_id, dependency_of_current_constraint_id)) {
                return true;
            }
        }

        return false;
    }

    return false;
}

bool dy_resolve_now_free_inference_vars(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr expr, size_t constraint_start, struct dy_core_expr *result)
{
    struct dy_core_expr ret = dy_core_expr_retain(ctx, expr);

    bool did_transform = false;
    for (size_t i = ctx->bound_inference_vars.num_elems; i-- > 0;) {
        struct dy_bound_inference_var *bound_inference_var = dy_array_pos(ctx->bound_inference_vars, i);

        remove_id(&bound_inference_var->binding_ids, id);

        if (bound_inference_var->binding_ids.num_elems != 0) {
            // Still bound.
            continue;
        }

        dy_retire_ids_array(ctx, bound_inference_var->binding_ids);
        
        struct dy_bound_inference_var copy = *bound_inference_var;

        dy_array_remove(&ctx->bound_inference_vars, i);

        struct dy_core_expr ret2;
        if (dy_resolve_inference_var(ctx, copy.id, copy.type, copy.polarity, ret, constraint_start, &ret2)) {
            did_transform = true;
            dy_core_expr_release(ctx, ret);
            ret = ret2;
        }

        i = ctx->bound_inference_vars.num_elems;
    }
    
    if (!did_transform) {
        dy_core_expr_release(ctx, ret);
        return false;
    } else {
        *result = ret;
        return true;
    }
}

bool dy_resolve_inference_var(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr type, enum dy_core_polarity polarity, struct dy_core_expr expr, size_t constraint_start, struct dy_core_expr *result)
{
    struct dy_core_expr sub;
    bool have_sub = dy_constraint_get(ctx, id, constraint_start, &sub);

    if (have_sub) {
        if (dy_core_expr_is_bound(ctx, id, sub)) {
            sub = (struct dy_core_expr){
                .tag = DY_CORE_EXPR_RECURSION,
                .recursion = {
                    .id = id,
                    .type = dy_core_expr_new(dy_core_expr_retain(ctx, type)),
                    .expr = dy_core_expr_new(sub),
                    .polarity = polarity,
                    .check_result = DY_YES
                }
            };
        }

        if (!substitute(ctx, expr, id, sub, &expr)) {
            expr = dy_core_expr_retain(ctx, expr);
        }
        
        dy_core_expr_release(ctx, sub);

        dy_free_first_constraints(ctx, constraint_start, ctx->constraints.num_elems);

        struct dy_core_expr new_expr;
        if (dy_check_expr(ctx, expr, &new_expr)) {
            dy_core_expr_release(ctx, expr);
            expr = new_expr;
        }

        if (dy_resolve_now_free_inference_vars(ctx, id, expr, constraint_start, &new_expr)) {
            dy_core_expr_release(ctx, expr);
            expr = new_expr;
        }
        
        *result = expr;
        return true;
    } else {
        dy_array_t ids = dy_new_ids_array(ctx);
        dy_collect_binding_inference_vars(ctx, id, constraint_start, &ids);

        if (ids.num_elems == 0) {
            dy_retire_ids_array(ctx, ids);

            struct dy_core_expr type_of_expr = dy_type_of(ctx, expr);
            bool appears_in_positive_position = false;
            bool appears_in_negative_position = false;

            dy_core_appears_in_polarity(ctx, id, type_of_expr, DY_CORE_POLARITY_POSITIVE, &appears_in_positive_position, &appears_in_negative_position);

            dy_core_expr_release(ctx, type_of_expr);

            if (appears_in_positive_position && appears_in_negative_position) {
                expr = (struct dy_core_expr){
                    .tag = DY_CORE_EXPR_TYPE_MAP,
                    .type_map = {
                        .id = id,
                        .type = dy_core_expr_new(dy_core_expr_retain(ctx, type)),
                        .polarity = DY_CORE_POLARITY_POSITIVE,
                        .expr = dy_core_expr_new(dy_core_expr_retain(ctx, expr)),
                        .is_implicit = true,
                    }
                };
            } else {
                struct dy_core_expr end = {
                    .tag = DY_CORE_EXPR_END,
                    .end_polarity = polarity
                };

                if (!substitute(ctx, expr, id, end, &expr)) {
                    expr = dy_core_expr_retain(ctx, expr);
                }
            }

            struct dy_core_expr new_expr;
            if (dy_resolve_now_free_inference_vars(ctx, id, expr, constraint_start, &new_expr)) {
                dy_core_expr_release(ctx, expr);
                expr = new_expr;
            }
            
            *result = expr;
            return true;
        } else {
            dy_array_add(&ctx->bound_inference_vars, &(struct dy_bound_inference_var){
                .id = id,
                .type = dy_core_expr_retain(ctx, type),
                .polarity = flip_polarity(polarity),
                .binding_ids = ids,
            });

            return false;
        }
    }
}

void remove_id(dy_array_t *ids, size_t id_to_remove)
{
    for (size_t i = 0, size = ids->num_elems; i < size; ++i) {
        size_t id;
        dy_array_get(*ids, i, &id);

        if (id == id_to_remove) {
            dy_array_remove(ids, i);
            return;
        }
    }
}

void remove_mentions_in_constraints(struct dy_core_ctx *ctx, size_t id, size_t start)
{
    for (size_t i = start, size = ctx->constraints.num_elems; i < size; ++i) {
        struct dy_constraint *c = dy_array_pos(ctx->constraints, i);

        struct dy_core_expr e;
        switch (c->polarity) {
        case DY_CORE_POLARITY_POSITIVE:
            if (remove_mentions_in_subtype(ctx, id, c->expr, &e)) {
                dy_core_expr_release(ctx, c->expr);
                c->expr = e;
            }

            continue;
        case DY_CORE_POLARITY_NEGATIVE:
            if (remove_mentions_in_supertype(ctx, id, c->expr, &e)) {
                dy_core_expr_release(ctx, c->expr);
                c->expr = e;
            }

            continue;
        }

        dy_bail("Impossible polarity");
    }
}

bool remove_mentions_in_subtype(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr subtype, struct dy_core_expr *result)
{
    switch (subtype.tag) {
    case DY_CORE_EXPR_EQUALITY_MAP: {
        if (dy_core_expr_is_bound(ctx, id, *subtype.equality_map.e1)) {
            if (subtype.equality_map.polarity == DY_CORE_POLARITY_NEGATIVE) {
                *result = (struct dy_core_expr){
                    .tag = DY_CORE_EXPR_END,
                    .end_polarity = DY_CORE_POLARITY_POSITIVE
                };
                return true;
            } else {
                struct dy_core_expr type_map = {
                    .tag = DY_CORE_EXPR_TYPE_MAP,
                    .type_map = {
                        .id = ctx->running_id++,
                        .type = dy_core_expr_new(dy_type_of(ctx, *subtype.equality_map.e1)),
                        .expr = dy_core_expr_retain_ptr(subtype.equality_map.e2),
                        .polarity = DY_CORE_POLARITY_NEGATIVE,
                        .is_implicit = subtype.equality_map.is_implicit,
                    }
                };

                if (remove_mentions_in_subtype(ctx, id, type_map, result)) {
                    dy_core_expr_release(ctx, type_map);
                } else {
                    *result = type_map;
                }

                return true;
            }
        }
        
        struct dy_core_expr e2;
        if (!remove_mentions_in_subtype(ctx, id, *subtype.equality_map.e2, &e2)) {
            return false;
        }
        
        dy_core_expr_retain_ptr(subtype.equality_map.e1);
        subtype.equality_map.e2 = dy_core_expr_new(e2);
        *result = subtype;
        return true;
    }
    case DY_CORE_EXPR_TYPE_MAP: {
        struct dy_core_expr type;
        bool type_is_new = remove_mentions_in_supertype(ctx, id, *subtype.type_map.type, &type);
        
        struct dy_core_expr expr;
        bool expr_is_new = remove_mentions_in_subtype(ctx, id, *subtype.type_map.expr, &expr);
        
        if (!type_is_new && !expr_is_new) {
            return false;
        }
        
        if (type_is_new) {
            subtype.type_map.type = dy_core_expr_new(type);
        } else {
            dy_core_expr_retain_ptr(subtype.type_map.type);
        }
        
        if (expr_is_new) {
            subtype.type_map.expr = dy_core_expr_new(expr);
        } else {
            dy_core_expr_retain_ptr(subtype.type_map.expr);
        }
        
        *result = subtype;
        return true;
    }
    case DY_CORE_EXPR_INFERENCE_TYPE_MAP: {
        struct dy_core_expr type;
        bool type_is_new = remove_mentions_in_supertype(ctx, id, *subtype.inference_type_map.type, &type);
        
        struct dy_core_expr expr;
        bool expr_is_new = remove_mentions_in_subtype(ctx, id, *subtype.inference_type_map.expr, &expr);
        
        if (!type_is_new && !expr_is_new) {
            return false;
        }
        
        if (type_is_new) {
            subtype.inference_type_map.type = dy_core_expr_new(type);
        } else {
            dy_core_expr_retain_ptr(subtype.inference_type_map.type);
        }
        
        if (expr_is_new) {
            subtype.inference_type_map.expr = dy_core_expr_new(expr);
        } else {
            dy_core_expr_retain_ptr(subtype.inference_type_map.expr);
        }
        
        *result = subtype;
        return true;
    }
    case DY_CORE_EXPR_EQUALITY_MAP_ELIM:
        // fallthrough
    case DY_CORE_EXPR_ALTERNATIVE:
        // fallthrough
    case DY_CORE_EXPR_TYPE_MAP_ELIM:
        if (dy_core_expr_is_bound(ctx, id, subtype)) {
            *result = (struct dy_core_expr){
                .tag = DY_CORE_EXPR_END,
                .end_polarity = DY_CORE_POLARITY_POSITIVE
            };
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_JUNCTION: {
        struct dy_core_expr e1;
        bool e1_is_new = remove_mentions_in_subtype(ctx, id, *subtype.junction.e1, &e1);
           
        struct dy_core_expr e2;
        bool e2_is_new = remove_mentions_in_subtype(ctx, id, *subtype.junction.e2, &e2);
           
       if (!e1_is_new && !e2_is_new) {
           return false;
       }
       
       if (e1_is_new) {
           subtype.junction.e1 = dy_core_expr_new(e1);
       } else {
           dy_core_expr_retain_ptr(subtype.junction.e1);
       }
       
       if (e2_is_new) {
           subtype.junction.e2 = dy_core_expr_new(e2);
       } else {
           dy_core_expr_retain_ptr(subtype.junction.e2);
       }
       
       *result = subtype;
       return true;
    }
    case DY_CORE_EXPR_RECURSION: {
        struct dy_core_expr type;
        bool type_is_new = remove_mentions_in_supertype(ctx, id, *subtype.recursion.type, &type);
        
        struct dy_core_expr expr;
        bool expr_is_new = remove_mentions_in_subtype(ctx, id, *subtype.recursion.expr, &expr);
        
        if (!type_is_new && !expr_is_new) {
            return false;
        }
        
        if (type_is_new) {
            subtype.recursion.type = dy_core_expr_new(type);
        } else {
            dy_core_expr_retain_ptr(subtype.recursion.type);
        }
        
        if (expr_is_new) {
            subtype.recursion.expr = dy_core_expr_new(expr);
        } else {
            dy_core_expr_retain_ptr(subtype.recursion.expr);
        }
        
        *result = subtype;
        return true;
    }
    case DY_CORE_EXPR_VARIABLE:
        if (subtype.variable_id == id) {
            *result = (struct dy_core_expr){
                .tag = DY_CORE_EXPR_END,
                .end_polarity = DY_CORE_POLARITY_POSITIVE
            };
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_CUSTOM: {
        const struct dy_core_custom_shared *s = dy_array_pos(ctx->custom_shared, subtype.custom.id);
        return s->remove_mentions_in_subtype(subtype.custom.data, ctx, id, result);
    }
    case DY_CORE_EXPR_END:
    case DY_CORE_EXPR_SYMBOL:
        return false;
    }

    dy_bail("Impossible object type.");
}

bool remove_mentions_in_supertype(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr supertype, struct dy_core_expr *result)
{
    switch (supertype.tag) {
    case DY_CORE_EXPR_EQUALITY_MAP: {
        if (dy_core_expr_is_bound(ctx, id, *supertype.equality_map.e1)) {
            if (supertype.equality_map.polarity == DY_CORE_POLARITY_POSITIVE) {
                *result = (struct dy_core_expr){
                    .tag = DY_CORE_EXPR_END,
                    .end_polarity = DY_CORE_POLARITY_NEGATIVE
                };
                return true;
            } else {
                struct dy_core_expr type_map = {
                    .tag = DY_CORE_EXPR_TYPE_MAP,
                    .type_map = {
                        .id = ctx->running_id++,
                        .type = dy_core_expr_new(dy_type_of(ctx, *supertype.equality_map.e1)),
                        .expr = dy_core_expr_retain_ptr(supertype.equality_map.e2),
                        .polarity = DY_CORE_POLARITY_POSITIVE,
                        .is_implicit = supertype.equality_map.is_implicit,
                    }
                };

                if (remove_mentions_in_supertype(ctx, id, type_map, result)) {
                    dy_core_expr_release(ctx, type_map);
                } else {
                    *result = type_map;
                }

                return true;
            }
        }
        
        struct dy_core_expr e2;
        if (!remove_mentions_in_supertype(ctx, id, *supertype.equality_map.e2, &e2)) {
            return false;
        }
        
        dy_core_expr_retain_ptr(supertype.equality_map.e1);
        supertype.equality_map.e2 = dy_core_expr_new(e2);
        *result = supertype;
        return true;
    }
    case DY_CORE_EXPR_TYPE_MAP: {
        struct dy_core_expr type;
        bool type_is_new = remove_mentions_in_subtype(ctx, id, *supertype.type_map.type, &type);
        
        struct dy_core_expr expr;
        bool expr_is_new = remove_mentions_in_supertype(ctx, id, *supertype.type_map.expr, &expr);
        
        if (!type_is_new && !expr_is_new) {
            return false;
        }
        
        if (type_is_new) {
            supertype.type_map.type = dy_core_expr_new(type);
        } else {
            dy_core_expr_retain_ptr(supertype.type_map.type);
        }
        
        if (expr_is_new) {
            supertype.type_map.expr = dy_core_expr_new(expr);
        } else {
            dy_core_expr_retain_ptr(supertype.type_map.expr);
        }
        
        *result = supertype;
        return true;
    }
    case DY_CORE_EXPR_INFERENCE_TYPE_MAP: {
        struct dy_core_expr type;
        bool type_is_new = remove_mentions_in_subtype(ctx, id, *supertype.inference_type_map.type, &type);
        
        struct dy_core_expr expr;
        bool expr_is_new = remove_mentions_in_supertype(ctx, id, *supertype.inference_type_map.expr, &expr);
        
        if (!type_is_new && !expr_is_new) {
            return false;
        }
        
        if (type_is_new) {
            supertype.inference_type_map.type = dy_core_expr_new(type);
        } else {
            dy_core_expr_retain_ptr(supertype.inference_type_map.type);
        }
        
        if (expr_is_new) {
            supertype.inference_type_map.expr = dy_core_expr_new(expr);
        } else {
            dy_core_expr_retain_ptr(supertype.inference_type_map.expr);
        }
        
        *result = supertype;
        return true;
    }
    case DY_CORE_EXPR_EQUALITY_MAP_ELIM:
        // fallthrough
    case DY_CORE_EXPR_ALTERNATIVE:
        // fallthrough
    case DY_CORE_EXPR_TYPE_MAP_ELIM:
        if (dy_core_expr_is_bound(ctx, id, supertype)) {
            *result = (struct dy_core_expr){
                .tag = DY_CORE_EXPR_END,
                .end_polarity = DY_CORE_POLARITY_NEGATIVE
            };
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_JUNCTION: {
        struct dy_core_expr e1;
        bool e1_is_new = remove_mentions_in_supertype(ctx, id, *supertype.junction.e1, &e1);
           
        struct dy_core_expr e2;
        bool e2_is_new = remove_mentions_in_supertype(ctx, id, *supertype.junction.e2, &e2);
           
       if (!e1_is_new && !e2_is_new) {
           return false;
       }
       
       if (e1_is_new) {
           supertype.junction.e1 = dy_core_expr_new(e1);
       } else {
           dy_core_expr_retain_ptr(supertype.junction.e1);
       }
       
       if (e2_is_new) {
           supertype.junction.e2 = dy_core_expr_new(e2);
       } else {
           dy_core_expr_retain_ptr(supertype.junction.e2);
       }
       
       *result = supertype;
       return true;
    }
    case DY_CORE_EXPR_RECURSION: {
        struct dy_core_expr type;
        bool type_is_new = remove_mentions_in_subtype(ctx, id, *supertype.recursion.type, &type);
        
        struct dy_core_expr expr;
        bool expr_is_new = remove_mentions_in_supertype(ctx, id, *supertype.recursion.expr, &expr);
        
        if (!type_is_new && !expr_is_new) {
            return false;
        }
        
        if (type_is_new) {
            supertype.recursion.type = dy_core_expr_new(type);
        } else {
            dy_core_expr_retain_ptr(supertype.recursion.type);
        }
        
        if (expr_is_new) {
            supertype.recursion.expr = dy_core_expr_new(expr);
        } else {
            dy_core_expr_retain_ptr(supertype.recursion.expr);
        }
        
        *result = supertype;
        return true;
    }
    case DY_CORE_EXPR_VARIABLE:
        if (supertype.variable_id == id) {
            *result = (struct dy_core_expr){
                .tag = DY_CORE_EXPR_END,
                .end_polarity = DY_CORE_POLARITY_NEGATIVE
            };
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_CUSTOM: {
        const struct dy_core_custom_shared *s = dy_array_pos(ctx->custom_shared, supertype.custom.id);
        return s->remove_mentions_in_supertype(supertype.custom.data, ctx, id, result);
    }
    case DY_CORE_EXPR_END:
    case DY_CORE_EXPR_SYMBOL:
        return false;
    }

    dy_bail("Impossible object type.");
}

dy_array_t dy_new_ids_array(struct dy_core_ctx *ctx)
{
    if (ctx->free_ids_arrays.num_elems == 0) {
        return dy_array_create(sizeof(size_t), DY_ALIGNOF(size_t), 4);
    } else {
        dy_array_t x;
        dy_array_pop(&ctx->free_ids_arrays, &x);
        return x;
    }
}

void dy_retire_ids_array(struct dy_core_ctx *ctx, dy_array_t array)
{
    dy_array_add(&ctx->free_ids_arrays, &array);
}
