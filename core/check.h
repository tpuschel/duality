/*
 * Copyright 2017-2020 Thorben Hasenpusch <t.hasenpusch@icloud.com>
 *
 * SPDX-License-Identifier: MIT
 */

#pragma once

#include "constraint.h"
#include "core.h"
#include "type_of.h"
#include "is_subtype.h"

#include "../support/bail.h"

/**
 * The functions here define the 'check' procedure for each object of Core.
 *
 * It has three purposes:
 *   (1) Update the subtype result of every elimination & recursion if needed.
 *   (2) Collect the constraints generated by (1).
 *   (3) Resolve inference contexts using the constraints of (2).
 *
 *  'check' is build as a pipeline:
 *   Expression comes in, validated & transformed expression + constraints come out.
 */

static inline struct dy_core_equality_map dy_check_equality_map(struct dy_core_ctx *ctx, struct dy_core_equality_map equality_map, struct dy_constraint *constraint, bool *did_generate_constraint);

static inline struct dy_core_type_map dy_check_type_map(struct dy_core_ctx *ctx, struct dy_core_type_map type_map, struct dy_constraint *constraint, bool *did_generate_constraint);

static inline struct dy_core_equality_map_elim dy_check_equality_map_elim(struct dy_core_ctx *ctx, struct dy_core_equality_map_elim elim, struct dy_constraint *constraint, bool *did_generate_constraint);

static inline struct dy_core_type_map_elim dy_check_type_map_elim(struct dy_core_ctx *ctx, struct dy_core_type_map_elim elim, struct dy_constraint *constraint, bool *did_generate_constraint);

static inline struct dy_core_junction dy_check_junction(struct dy_core_ctx *ctx, struct dy_core_junction junction, struct dy_constraint *constraint, bool *did_generate_constraint);

static inline struct dy_core_alternative dy_check_alternative(struct dy_core_ctx *ctx, struct dy_core_alternative alternative, struct dy_constraint *constraint, bool *did_generate_constraint);

static inline struct dy_core_expr dy_check_inference_type_map(struct dy_core_ctx *ctx, struct dy_core_inference_type_map inference_type_map, struct dy_constraint *constraint, bool *did_generate_constraint);

static inline struct dy_core_recursion dy_check_recursion(struct dy_core_ctx *ctx, struct dy_core_recursion recursion, struct dy_constraint *constraint, bool *did_generate_constraint);

static inline const struct dy_constraint *alloc_constraint(struct dy_constraint constraint);

static inline dy_array_t dy_deep_copy_bound_constraints(struct dy_core_ctx *ctx);

/**
 * Collects the id of every constraint that mentions 'id'.
 * If the size of 'ids' isn't changed upon returning, 'id' is "free" and can be resolved.
 */
static inline void dy_binding_contraints(struct dy_core_ctx *ctx, size_t id, struct dy_constraint constraint, bool have_constraint, dy_array_t *ids);

static inline bool dy_is_dependency_of_constraint(struct dy_core_ctx *ctx, size_t potential_dependency_id, size_t current_constraint_id);

static inline struct dy_core_expr dy_free_constraint(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr expr);

/**
 * Just removes 'id' from 'ids', if present.
 */
static inline void remove_id(dy_array_t *ids, size_t id);

/**
 * Removes all mentions of 'id' in 'constraint', which may involve lowering/raising the subtype/supertype bounds.
 */
static inline struct dy_constraint remove_mentions_in_constraint(struct dy_core_ctx *ctx, size_t id, struct dy_constraint constraint);

/**
 * Removes all mentions of 'id'. The returned type is always a supertype of 'subtype'.
 */
static inline struct dy_core_expr remove_mentions_in_subtype(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr subtype);

/**
 * Removes all mentions of 'id'. The returned type is always a subtype of 'supertype'.
 */
static inline struct dy_core_expr remove_mentions_in_supertype(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr supertype);

struct dy_core_expr dy_check_expr(struct dy_core_ctx *ctx, struct dy_core_expr expr, struct dy_constraint *constraint, bool *did_generate_constraint)
{
    switch (expr.tag) {
    case DY_CORE_EXPR_EQUALITY_MAP:
        expr.equality_map = dy_check_equality_map(ctx, expr.equality_map, constraint, did_generate_constraint);
        return expr;
    case DY_CORE_EXPR_TYPE_MAP:
        expr.type_map = dy_check_type_map(ctx, expr.type_map, constraint, did_generate_constraint);
        return expr;
    case DY_CORE_EXPR_EQUALITY_MAP_ELIM:
        expr.equality_map_elim = dy_check_equality_map_elim(ctx, expr.equality_map_elim, constraint, did_generate_constraint);
        return expr;
    case DY_CORE_EXPR_TYPE_MAP_ELIM:
        expr.type_map_elim = dy_check_type_map_elim(ctx, expr.type_map_elim, constraint, did_generate_constraint);
        return expr;
    case DY_CORE_EXPR_JUNCTION:
        expr.junction = dy_check_junction(ctx, expr.junction, constraint, did_generate_constraint);
        return expr;
    case DY_CORE_EXPR_RECURSION:
        expr.recursion = dy_check_recursion(ctx, expr.recursion, constraint, did_generate_constraint);
        return expr;
    case DY_CORE_EXPR_ALTERNATIVE:
        expr.alternative = dy_check_alternative(ctx, expr.alternative, constraint, did_generate_constraint);
        return expr;
    case DY_CORE_EXPR_INFERENCE_TYPE_MAP:
        return dy_check_inference_type_map(ctx, expr.inference_type_map, constraint, did_generate_constraint);
    case DY_CORE_EXPR_VARIABLE:
        return dy_core_expr_retain(expr);
    case DY_CORE_EXPR_INFERENCE_VARIABLE:
        return dy_core_expr_retain(expr);
    case DY_CORE_EXPR_END:
        return dy_core_expr_retain(expr);
    case DY_CORE_EXPR_CUSTOM:
        return expr.custom.check(expr.custom.data, ctx, constraint, did_generate_constraint);
    case DY_CORE_EXPR_SYMBOL:
        return dy_core_expr_retain(expr);
    }

    dy_bail("Impossible object type.");
}

struct dy_core_equality_map dy_check_equality_map(struct dy_core_ctx *ctx, struct dy_core_equality_map equality_map, struct dy_constraint *constraint, bool *did_generate_constraint)
{
    struct dy_constraint c1;
    bool have_c1 = false;
    struct dy_core_expr e1 = dy_check_expr(ctx, *equality_map.e1, &c1, &have_c1);
    equality_map.e1 = dy_core_expr_new(e1);

    struct dy_constraint c2;
    bool have_c2 = false;
    struct dy_core_expr e2 = dy_check_expr(ctx, *equality_map.e2, &c2, &have_c2);
    equality_map.e2 = dy_core_expr_new(e2);

    if (have_c1 && have_c2) {
        *constraint = (struct dy_constraint){
            .tag = DY_CONSTRAINT_MULTIPLE,
            .multiple = {
                .c1 = alloc_constraint(c1),
                .c2 = alloc_constraint(c2),
                .polarity = DY_CORE_POLARITY_POSITIVE,
            }
        };
        *did_generate_constraint = true;
    } else if (have_c1) {
        *constraint = c1;
        *did_generate_constraint = true;
    } else if (have_c2) {
        *constraint = c2;
        *did_generate_constraint = true;
    }

    return equality_map;
}

struct dy_core_type_map dy_check_type_map(struct dy_core_ctx *ctx, struct dy_core_type_map type_map, struct dy_constraint *constraint, bool *did_generate_constraint)
{
    struct dy_constraint c1;
    bool have_c1 = false;
    struct dy_core_expr type = dy_check_expr(ctx, *type_map.binding.type, &c1, &have_c1);
    type_map.binding.type = dy_core_expr_new(type);

    struct dy_core_expr new_unknown = {
        .tag = DY_CORE_EXPR_VARIABLE,
        .variable = {
            .id = type_map.binding.id,
            .type = dy_core_expr_new(dy_core_expr_retain(type)),
        },
    };

    struct dy_core_expr expr = substitute(*type_map.expr, type_map.binding.id, new_unknown);

    dy_core_expr_release(new_unknown);

    struct dy_constraint c2;
    bool have_c2 = false;
    struct dy_core_expr new_expr = dy_check_expr(ctx, expr, &c2, &have_c2);

    dy_core_expr_release(expr);
    type_map.expr = dy_core_expr_new(new_expr);

    if (have_c2) {
        struct dy_constraint c3 = remove_mentions_in_constraint(ctx, type_map.binding.id, c2);
        // free c2
        c2 = c3;
    }

    if (have_c1 && have_c2) {
        *constraint = (struct dy_constraint){
            .tag = DY_CONSTRAINT_MULTIPLE,
            .multiple = {
                .c1 = alloc_constraint(c1),
                .c2 = alloc_constraint(c2),
                .polarity = DY_CORE_POLARITY_POSITIVE,
            }
        };
        *did_generate_constraint = true;
    } else if (have_c1) {
        *constraint = c1;
        *did_generate_constraint = true;
    } else if (have_c2) {
        *constraint = c2;
        *did_generate_constraint = true;
    }

    return type_map;
}

struct dy_core_equality_map_elim dy_check_equality_map_elim(struct dy_core_ctx *ctx, struct dy_core_equality_map_elim elim, struct dy_constraint *constraint, bool *did_generate_constraint)
{
    struct dy_constraint c1;
    bool have_c1 = false;
    struct dy_core_expr expr = dy_check_expr(ctx, *elim.expr, &c1, &have_c1);

    struct dy_constraint c2;
    bool have_c2 = false;
    elim.map = dy_check_equality_map(ctx, elim.map, &c2, &have_c2);

    struct dy_constraint c3;
    bool have_c3 = false;
    if (elim.check_result == DY_MAYBE) {
        struct dy_core_expr type_of_expr = dy_type_of(ctx, expr);

        struct dy_core_expr new_expr;
        if (dy_core_expr_is_computation(*elim.map.e1)) {
            struct dy_core_expr type_of_equality_map_e1 = dy_type_of(ctx, *elim.map.e1);

            struct dy_core_expr type_map_expr = {
                .tag = DY_CORE_EXPR_TYPE_MAP,
                .type_map = {
                    .binding = {
                        .id = ctx->running_id++,
                        .type = dy_core_expr_new(type_of_equality_map_e1),
                    },
                    .expr = dy_core_expr_retain_ptr(elim.map.e2),
                    .polarity = DY_CORE_POLARITY_POSITIVE,
                    .is_implicit = elim.map.is_implicit,
                }
            };

            elim.check_result = dy_is_subtype(ctx, type_of_expr, type_map_expr, &c3, &have_c3, expr, &new_expr);

            dy_core_expr_release(type_of_equality_map_e1);
        } else {
            struct dy_core_expr equality_map_expr = {
                .tag = DY_CORE_EXPR_EQUALITY_MAP,
                .equality_map = elim.map
            };

            elim.check_result = dy_is_subtype(ctx, type_of_expr, equality_map_expr, &c3, &have_c3, expr, &new_expr);
        }

        dy_core_expr_release(type_of_expr);
        dy_core_expr_release(expr);

        expr = new_expr;
    }

    elim.expr = dy_core_expr_new(expr);

    if (have_c1 && have_c2 && have_c3) {
        struct dy_constraint c = {
            .tag = DY_CONSTRAINT_MULTIPLE,
            .multiple = {
                .c1 = alloc_constraint(c1),
                .c2 = alloc_constraint(c2),
                .polarity = DY_CORE_POLARITY_POSITIVE,
            }
        };

        *constraint = (struct dy_constraint){
            .tag = DY_CONSTRAINT_MULTIPLE,
            .multiple = {
                .c1 = alloc_constraint(c),
                .c2 = alloc_constraint(c3),
                .polarity = DY_CORE_POLARITY_POSITIVE,
            }
        };

        *did_generate_constraint = true;
    } else if (have_c1 && have_c2) {
        *constraint = (struct dy_constraint){
            .tag = DY_CONSTRAINT_MULTIPLE,
            .multiple = {
                .c1 = alloc_constraint(c1),
                .c2 = alloc_constraint(c2),
                .polarity = DY_CORE_POLARITY_POSITIVE,
            }
        };
        *did_generate_constraint = true;
    } else if (have_c2 && have_c3) {
        *constraint = (struct dy_constraint){
            .tag = DY_CONSTRAINT_MULTIPLE,
            .multiple = {
                .c1 = alloc_constraint(c2),
                .c2 = alloc_constraint(c3),
                .polarity = DY_CORE_POLARITY_POSITIVE,
            }
        };
        *did_generate_constraint = true;
    } else if (have_c1 && have_c3) {
        *constraint = (struct dy_constraint){
            .tag = DY_CONSTRAINT_MULTIPLE,
            .multiple = {
                .c1 = alloc_constraint(c1),
                .c2 = alloc_constraint(c3),
                .polarity = DY_CORE_POLARITY_POSITIVE,
            }
        };
        *did_generate_constraint = true;
    } else if (have_c1) {
        *constraint = c1;
        *did_generate_constraint = true;
    } else if (have_c2) {
        *constraint = c2;
        *did_generate_constraint = true;
    } else if (have_c3) {
        *constraint = c3;
        *did_generate_constraint = true;
    }

    return elim;
}

struct dy_core_type_map_elim dy_check_type_map_elim(struct dy_core_ctx *ctx, struct dy_core_type_map_elim elim, struct dy_constraint *constraint, bool *did_generate_constraint)
{
    struct dy_constraint c1;
    bool have_c1 = false;
    struct dy_core_expr expr = dy_check_expr(ctx, *elim.expr, &c1, &have_c1);

    struct dy_constraint c2;
    bool have_c2 = false;
    elim.map = dy_check_type_map(ctx, elim.map, &c2, &have_c2);

    struct dy_constraint c3;
    bool have_c3 = false;
    if (elim.check_result == DY_MAYBE) {
        struct dy_core_expr type_map_expr = {
            .tag = DY_CORE_EXPR_TYPE_MAP,
            .type_map = elim.map
        };

        struct dy_core_expr type_of_expr = dy_type_of(ctx, expr);

        struct dy_core_expr new_expr;
        elim.check_result = dy_is_subtype(ctx, type_of_expr, type_map_expr, &c3, &have_c3, expr, &new_expr);

        dy_core_expr_release(type_of_expr);
        dy_core_expr_release(expr);

        expr = new_expr;
    }

    elim.expr = dy_core_expr_new(expr);

    if (have_c1 && have_c2 && have_c3) {
        struct dy_constraint c = {
            .tag = DY_CONSTRAINT_MULTIPLE,
            .multiple = {
                .c1 = alloc_constraint(c1),
                .c2 = alloc_constraint(c2),
                .polarity = DY_CORE_POLARITY_POSITIVE,
            }
        };

        *constraint = (struct dy_constraint){
            .tag = DY_CONSTRAINT_MULTIPLE,
            .multiple = {
                .c1 = alloc_constraint(c),
                .c2 = alloc_constraint(c3),
                .polarity = DY_CORE_POLARITY_POSITIVE,
            }
        };

        *did_generate_constraint = true;
    } else if (have_c1 && have_c2) {
        *constraint = (struct dy_constraint){
            .tag = DY_CONSTRAINT_MULTIPLE,
            .multiple = {
                .c1 = alloc_constraint(c1),
                .c2 = alloc_constraint(c2),
                .polarity = DY_CORE_POLARITY_POSITIVE,
            }
        };
        *did_generate_constraint = true;
    } else if (have_c2 && have_c3) {
        *constraint = (struct dy_constraint){
            .tag = DY_CONSTRAINT_MULTIPLE,
            .multiple = {
                .c1 = alloc_constraint(c2),
                .c2 = alloc_constraint(c3),
                .polarity = DY_CORE_POLARITY_POSITIVE,
            }
        };
        *did_generate_constraint = true;
    } else if (have_c1 && have_c3) {
        *constraint = (struct dy_constraint){
            .tag = DY_CONSTRAINT_MULTIPLE,
            .multiple = {
                .c1 = alloc_constraint(c1),
                .c2 = alloc_constraint(c3),
                .polarity = DY_CORE_POLARITY_POSITIVE,
            }
        };
        *did_generate_constraint = true;
    } else if (have_c1) {
        *constraint = c1;
        *did_generate_constraint = true;
    } else if (have_c2) {
        *constraint = c2;
        *did_generate_constraint = true;
    } else if (have_c3) {
        *constraint = c3;
        *did_generate_constraint = true;
    }

    return elim;
}

struct dy_core_junction dy_check_junction(struct dy_core_ctx *ctx, struct dy_core_junction junction, struct dy_constraint *constraint, bool *did_generate_constraint)
{
    struct dy_constraint c1;
    bool have_c1 = false;
    struct dy_core_expr e1 = dy_check_expr(ctx, *junction.e1, &c1, &have_c1);
    junction.e1 = dy_core_expr_new(e1);

    struct dy_constraint c2;
    bool have_c2 = false;
    struct dy_core_expr e2 = dy_check_expr(ctx, *junction.e2, &c2, &have_c2);
    junction.e2 = dy_core_expr_new(e2);

    if (have_c1 && have_c2) {
        *constraint = (struct dy_constraint){
            .tag = DY_CONSTRAINT_MULTIPLE,
            .multiple = {
                .c1 = alloc_constraint(c1),
                .c2 = alloc_constraint(c2),
                .polarity = DY_CORE_POLARITY_POSITIVE,
            }
        };
        *did_generate_constraint = true;
    } else if (have_c1) {
        *constraint = c1;
        *did_generate_constraint = true;
    } else if (have_c2) {
        *constraint = c2;
        *did_generate_constraint = true;
    }

    return junction;
}

struct dy_core_alternative dy_check_alternative(struct dy_core_ctx *ctx, struct dy_core_alternative alternative, struct dy_constraint *constraint, bool *did_generate_constraint)
{
    struct dy_constraint c1;
    bool have_c1 = false;
    struct dy_core_expr first = dy_check_expr(ctx, *alternative.first, &c1, &have_c1);
    alternative.first = dy_core_expr_new(first);

    struct dy_constraint c2;
    bool have_c2 = false;
    struct dy_core_expr second = dy_check_expr(ctx, *alternative.second, &c2, &have_c2);
    alternative.second = dy_core_expr_new(second);

    if (have_c1 && have_c2) {
        *constraint = (struct dy_constraint){
            .tag = DY_CONSTRAINT_MULTIPLE,
            .multiple = {
                .c1 = alloc_constraint(c1),
                .c2 = alloc_constraint(c2),
                .polarity = DY_CORE_POLARITY_NEGATIVE,
            }
        };
        *did_generate_constraint = true;
    } else if (have_c1) {
        *constraint = c1;
        *did_generate_constraint = true;
    } else if (have_c2) {
        *constraint = c2;
        *did_generate_constraint = true;
    }

    return alternative;
}

struct dy_core_recursion dy_check_recursion(struct dy_core_ctx *ctx, struct dy_core_recursion recursion, struct dy_constraint *constraint, bool *did_generate_constraint)
{
    size_t inference_id = ctx->running_id++;

    struct dy_core_expr any = {
        .tag = DY_CORE_EXPR_END,
        .end_polarity = DY_CORE_POLARITY_NEGATIVE
    };

    struct dy_core_expr inference_var = {
        .tag = DY_CORE_EXPR_INFERENCE_VARIABLE,
        .inference_variable = {
            .id = inference_id,
            .type = dy_core_expr_new(any),
            .polarity = DY_CORE_POLARITY_NEGATIVE,
        }
    };

    struct dy_core_expr provisional_type = {
        .tag = DY_CORE_EXPR_VARIABLE,
        .variable = {
            .id = recursion.id,
            .type = dy_core_expr_new(inference_var),
        }
    };

    struct dy_core_expr new_body = substitute(*recursion.expr, recursion.id, provisional_type);

    dy_core_expr_release(provisional_type);

    dy_array_t bc_copy = dy_deep_copy_bound_constraints(ctx);

    struct dy_constraint c;
    bool have_c = false;
    struct dy_core_expr checked_body = dy_check_expr(ctx, new_body, &c, &have_c);

    ctx->bound_constraints = bc_copy;

    dy_core_expr_release(new_body);

    struct dy_core_expr type_of_body = dy_type_of(ctx, checked_body);

    dy_core_expr_release(checked_body);

    struct dy_core_expr self_type = {
        .tag = DY_CORE_EXPR_VARIABLE,
        .variable = {
            .id = recursion.id,
            .type = dy_core_expr_new(any),
        }
    };

    struct dy_core_expr actual_type = substitute(type_of_body, inference_id, self_type);

    dy_core_expr_release(type_of_body);
    dy_core_expr_release(self_type);

    struct dy_core_expr self = {
        .tag = DY_CORE_EXPR_VARIABLE,
        .variable = {
            .id = recursion.id,
            .type = dy_core_expr_new(actual_type),
        }
    };

    struct dy_core_expr actual_body = substitute(*recursion.expr, recursion.id, self);

    dy_core_expr_release(self);

    struct dy_core_expr checked_actual_body = dy_check_expr(ctx, actual_body, constraint, did_generate_constraint);

    dy_core_expr_release(actual_body);

    recursion.expr = dy_core_expr_new(checked_actual_body);

    return recursion;
}

struct dy_core_expr dy_check_inference_type_map(struct dy_core_ctx *ctx, struct dy_core_inference_type_map inference_type_map, struct dy_constraint *constraint, bool *did_generate_constraint)
{
    struct dy_constraint c1;
    bool have_c1 = false;
    struct dy_core_expr type = dy_check_expr(ctx, *inference_type_map.binding.type, &c1, &have_c1);

    struct dy_core_expr new_unknown = {
        .tag = DY_CORE_EXPR_INFERENCE_VARIABLE,
        .inference_variable = {
            .id = inference_type_map.binding.id,
            .type = dy_core_expr_new(dy_core_expr_retain(type)),
            .polarity = inference_type_map.polarity,
        },
    };

    struct dy_core_expr inner_expr = substitute(*inference_type_map.expr, inference_type_map.binding.id, new_unknown);

    dy_core_expr_release(new_unknown);

    struct dy_constraint c2;
    bool have_c2 = false;
    struct dy_core_expr new_inner_expr = dy_check_expr(ctx, inner_expr, &c2, &have_c2);

    dy_core_expr_release(inner_expr);

    struct dy_core_expr result;
    bool have_result;
    if (have_c2) {
        have_result = dy_constraint_collect(c2, inference_type_map.binding.id, inference_type_map.polarity, &result);
    } else {
        have_result = false;
    }

    if (have_result) {
        if (dy_core_expr_is_bound(inference_type_map.binding.id, result)) {
            struct dy_core_expr new_var = {
                .tag = DY_CORE_EXPR_VARIABLE,
                .variable = {
                    .id = inference_type_map.binding.id,
                    .type = dy_core_expr_new(dy_core_expr_retain(type)),
                }
            };

            struct dy_core_expr result2 = substitute(result, inference_type_map.binding.id, new_var);

            dy_core_expr_release(result);

            dy_core_expr_release(new_var);

            result = (struct dy_core_expr){
                .tag = DY_CORE_EXPR_RECURSION,
                .recursion = {
                    .id = inference_type_map.binding.id,
                    .expr = dy_core_expr_new(result2),
                    .polarity = inference_type_map.polarity,
                }
            };
        }

        inner_expr = substitute(new_inner_expr, inference_type_map.binding.id, result);

        dy_core_expr_release(new_inner_expr);

        new_inner_expr = dy_free_constraint(ctx, inference_type_map.binding.id, inner_expr);

        dy_core_expr_release(inner_expr);

        have_c2 = false;
        inner_expr = dy_check_expr(ctx, new_inner_expr, &c2, &have_c2);

        dy_core_expr_release(new_inner_expr);

        new_inner_expr = inner_expr;
    } else {
        dy_array_t ids = dy_array_create(sizeof(size_t), DY_ALIGNOF(size_t), 4);
        dy_binding_contraints(ctx, inference_type_map.binding.id, c2, have_c2, &ids);

        if (ids.num_elems == 0) {
            dy_array_destroy(ids);

            dy_core_expr_release(type);

            struct dy_core_expr type_of_inner_expr = dy_type_of(ctx, new_inner_expr);

            if (dy_core_appears_in_opposite_polarity(inference_type_map.binding.id, type_of_inner_expr, DY_CORE_POLARITY_POSITIVE)) {
                struct dy_core_expr unknown = {
                    .tag = DY_CORE_EXPR_VARIABLE,
                    .variable = {
                        .id = inference_type_map.binding.id,
                        .type = dy_core_expr_new(dy_core_expr_retain(type)),
                    }
                };

                inner_expr = substitute(new_inner_expr, inference_type_map.binding.id, unknown);

                dy_core_expr_release(unknown);
                dy_core_expr_release(new_inner_expr);

                new_inner_expr = (struct dy_core_expr){
                    .tag = DY_CORE_EXPR_TYPE_MAP,
                    .type_map = {
                        .binding = {
                            .id = inference_type_map.binding.id,
                            .type = dy_core_expr_new(dy_core_expr_retain(type)),
                        },
                        .polarity = DY_CORE_POLARITY_POSITIVE,
                        .expr = dy_core_expr_new(inner_expr),
                        .is_implicit = true,
                    }
                };
            } else {
                struct dy_core_expr end = {
                    .tag = DY_CORE_EXPR_END,
                    .end_polarity = inference_type_map.polarity
                };

                inner_expr = substitute(new_inner_expr, inference_type_map.binding.id, end);

                dy_core_expr_release(new_inner_expr);

                new_inner_expr = inner_expr;
            }

            dy_core_expr_release(type_of_inner_expr);

            inner_expr = dy_free_constraint(ctx, inference_type_map.binding.id, new_inner_expr);

            dy_core_expr_release(new_inner_expr);

            have_c2 = false;
            new_inner_expr = dy_check_expr(ctx, inner_expr, &c2, &have_c2);

            dy_core_expr_release(inner_expr);
        } else {
            struct dy_core_expr inference_var = {
                .tag = DY_CORE_EXPR_INFERENCE_VARIABLE,
                .inference_variable = {
                    .id = inference_type_map.binding.id,
                    .type = dy_core_expr_new(dy_core_expr_retain(type)),
                    .polarity = flip_polarity(inference_type_map.polarity),
                }
            };

            inner_expr = substitute(new_inner_expr, inference_type_map.binding.id, inference_var);

            dy_core_expr_release(new_inner_expr);

            have_c2 = false;
            new_inner_expr = dy_check_expr(ctx, inner_expr, &c2, &have_c2);

            dy_core_expr_release(inner_expr);

            struct dy_bound_constraint bound_constraint = {
                .id = inference_type_map.binding.id,
                .type = type,
                .polarity = flip_polarity(inference_type_map.polarity),
                .binding_ids = ids
            };

            dy_array_add(&ctx->bound_constraints, &bound_constraint);
        }
    }

    if (have_c1 && have_c2) {
        *constraint = (struct dy_constraint){
            .tag = DY_CONSTRAINT_MULTIPLE,
            .multiple = {
                .c1 = alloc_constraint(c1),
                .c2 = alloc_constraint(c2),
                .polarity = DY_CORE_POLARITY_POSITIVE,
            }
        };
        *did_generate_constraint = true;
    } else if (have_c1) {
        *constraint = c1;
        *did_generate_constraint = true;
    } else if (have_c2) {
        *constraint = c2;
        *did_generate_constraint = true;
    }

    return new_inner_expr;
}

void dy_binding_contraints(struct dy_core_ctx *ctx, size_t id, struct dy_constraint constraint, bool have_constraint, dy_array_t *ids)
{
    if (!have_constraint) {
        return;
    }

    switch (constraint.tag) {
    case DY_CONSTRAINT_SINGLE:
        if (constraint.single.id == id) {
            return;
        }

        // No duplicates.
        for (size_t i = 0; i < ids->num_elems; ++i) {
            size_t binding_id;
            dy_array_get(*ids, i, &binding_id);

            if (constraint.single.id == binding_id) {
                return;
            }
        }

        size_t old_size = ctx->already_visited_ids.num_elems;
        bool is_dependency = dy_is_dependency_of_constraint(ctx, id, constraint.single.id);
        ctx->already_visited_ids.num_elems = old_size;
        if (is_dependency) {
            return;
        }

        if (dy_core_expr_is_bound(id, constraint.single.expr)) {
            dy_array_add(ids, &constraint.single.id);
            return;
        }

        return;
    case DY_CONSTRAINT_MULTIPLE:
        dy_binding_contraints(ctx, id, *constraint.multiple.c1, true, ids);
        dy_binding_contraints(ctx, id, *constraint.multiple.c2, true, ids);
        return;
    }

    dy_bail("Impossible constraint type.");
}

bool dy_is_dependency_of_constraint(struct dy_core_ctx *ctx, size_t potential_dependency_id, size_t current_constraint_id)
{
    dy_array_add(&ctx->already_visited_ids, &current_constraint_id);

    for (size_t i = ctx->bound_constraints.num_elems; i-- > 0;) {
        struct dy_bound_constraint bound_constraint;
        dy_array_get(ctx->bound_constraints, i, &bound_constraint);

        if (current_constraint_id != bound_constraint.id) {
            continue;
        }

        for (size_t k = 0; k < bound_constraint.binding_ids.num_elems; ++k) {
            size_t dependency_of_current_constraint_id;
            dy_array_get(bound_constraint.binding_ids, k, &dependency_of_current_constraint_id);

            if (dependency_of_current_constraint_id == potential_dependency_id) {
                return true;
            }

            bool skip_id = false;
            for (size_t h = 0; h < ctx->already_visited_ids.num_elems; ++h) {
                size_t already_visited_id;
                dy_array_get(ctx->already_visited_ids, h, &already_visited_id);

                if (already_visited_id == dependency_of_current_constraint_id) {
                    skip_id = true;
                    break;
                }
            }

            if (skip_id) {
                continue;
            }

            if (dy_is_dependency_of_constraint(ctx, potential_dependency_id, dependency_of_current_constraint_id)) {
                return true;
            }
        }

        return false;
    }

    return false;
}

struct dy_core_expr dy_free_constraint(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr expr)
{
    struct dy_core_expr ret = dy_core_expr_retain(expr);
    for (size_t i = ctx->bound_constraints.num_elems; i-- > 0;) {
        struct dy_bound_constraint *bound_constraint = dy_array_pos(ctx->bound_constraints, i);

        remove_id(&bound_constraint->binding_ids, id);

        if (bound_constraint->binding_ids.num_elems != 0) {
            continue;
        }

        dy_array_destroy(bound_constraint->binding_ids);

        struct dy_core_expr inference_var = {
            .tag = DY_CORE_EXPR_INFERENCE_VARIABLE,
            .inference_variable = {
                .id = bound_constraint->id,
                .type = dy_core_expr_new(dy_core_expr_retain(bound_constraint->type)),
                .polarity = bound_constraint->polarity,
            }
        };

        struct dy_core_expr e = substitute(ret, bound_constraint->id, inference_var);

        dy_core_expr_release(ret);

        ret = (struct dy_core_expr){
            .tag = DY_CORE_EXPR_INFERENCE_TYPE_MAP,
            .inference_type_map = {
                .binding = {
                    .id = bound_constraint->id,
                    .type = dy_core_expr_new(dy_core_expr_retain(bound_constraint->type)),
                },
                .expr = dy_core_expr_new(e),
                .polarity = bound_constraint->polarity,
            }
        };

        struct dy_bound_constraint copy = *bound_constraint;

        dy_array_remove(&ctx->bound_constraints, i);

        e = dy_free_constraint(ctx, copy.id, ret);

        dy_core_expr_release(ret);

        ret = e;

        i = ctx->bound_constraints.num_elems;
    }

    return ret;
}

void remove_id(dy_array_t *ids, size_t id_to_remove)
{
    for (size_t i = 0, size = ids->num_elems; i < size; ++i) {
        size_t id;
        dy_array_get(*ids, i, &id);

        if (id == id_to_remove) {
            dy_array_remove(ids, i);
            return;
        }
    }
}

struct dy_constraint remove_mentions_in_constraint(struct dy_core_ctx *ctx, size_t id, struct dy_constraint constraint)
{
    switch (constraint.tag) {
    case DY_CONSTRAINT_SINGLE:
        switch (constraint.single.polarity) {
        case DY_CORE_POLARITY_POSITIVE:
            constraint.single.expr = remove_mentions_in_subtype(ctx, id, constraint.single.expr);
            return constraint;
        case DY_CORE_POLARITY_NEGATIVE:
            constraint.single.expr = remove_mentions_in_supertype(ctx, id, constraint.single.expr);
            return constraint;
        }
    case DY_CONSTRAINT_MULTIPLE:
        constraint.multiple.c1 = alloc_constraint(remove_mentions_in_constraint(ctx, id, *constraint.multiple.c1));
        constraint.multiple.c2 = alloc_constraint(remove_mentions_in_constraint(ctx, id, *constraint.multiple.c2));
        return constraint;
    }
}

struct dy_core_expr remove_mentions_in_subtype(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr subtype)
{
    switch (subtype.tag) {
    case DY_CORE_EXPR_EQUALITY_MAP:
        if (dy_core_expr_is_bound(id, *subtype.equality_map.e1)) {
            if (subtype.equality_map.polarity == DY_CORE_POLARITY_NEGATIVE) {
                return (struct dy_core_expr){
                    .tag = DY_CORE_EXPR_END,
                    .end_polarity = DY_CORE_POLARITY_NEGATIVE
                };
            } else {
                struct dy_core_expr type_map = {
                    .tag = DY_CORE_EXPR_TYPE_MAP,
                    .type_map = {
                        .binding = {
                            .id = ctx->running_id++,
                            .type = dy_core_expr_new(dy_type_of(ctx, *subtype.equality_map.e1)),
                        },
                        .expr = dy_core_expr_retain_ptr(subtype.equality_map.e2),
                        .polarity = DY_CORE_POLARITY_NEGATIVE,
                        .is_implicit = subtype.equality_map.is_implicit,
                    }
                };

                struct dy_core_expr e = remove_mentions_in_subtype(ctx, id, type_map);

                dy_core_expr_release(type_map);

                return e;
            }
        }

        subtype.equality_map.e2 = dy_core_expr_new(remove_mentions_in_subtype(ctx, id, *subtype.equality_map.e2));
        return subtype;
    case DY_CORE_EXPR_TYPE_MAP:
        subtype.type_map.binding.type = dy_core_expr_new(remove_mentions_in_supertype(ctx, id, *subtype.type_map.binding.type));
        subtype.type_map.expr = dy_core_expr_new(remove_mentions_in_subtype(ctx, id, *subtype.type_map.expr));
        return subtype;
    case DY_CORE_EXPR_INFERENCE_TYPE_MAP:
        subtype.inference_type_map.binding.type = dy_core_expr_new(remove_mentions_in_supertype(ctx, id, *subtype.inference_type_map.binding.type));
        subtype.inference_type_map.expr = dy_core_expr_new(remove_mentions_in_subtype(ctx, id, *subtype.inference_type_map.expr));
        return subtype;
    case DY_CORE_EXPR_EQUALITY_MAP_ELIM:
        // fallthrough
    case DY_CORE_EXPR_ALTERNATIVE:
        // fallthrough
    case DY_CORE_EXPR_TYPE_MAP_ELIM:
        if (dy_core_expr_is_bound(id, subtype)) {
            return (struct dy_core_expr){
                .tag = DY_CORE_EXPR_END,
                .end_polarity = DY_CORE_POLARITY_NEGATIVE
            };
        } else {
            return subtype;
        }
    case DY_CORE_EXPR_JUNCTION:
        subtype.junction.e1 = dy_core_expr_new(remove_mentions_in_subtype(ctx, id, *subtype.junction.e1));
        subtype.junction.e2 = dy_core_expr_new(remove_mentions_in_subtype(ctx, id, *subtype.junction.e2));
        return subtype;
    case DY_CORE_EXPR_RECURSION:
        subtype.recursion.expr = dy_core_expr_new(remove_mentions_in_subtype(ctx, id, *subtype.recursion.expr));
        return subtype;
    case DY_CORE_EXPR_VARIABLE:
        if (subtype.variable.id == id) {
            return (struct dy_core_expr){
                .tag = DY_CORE_EXPR_END,
                .end_polarity = DY_CORE_POLARITY_NEGATIVE
            };
        } else {
            return subtype;
        }
    case DY_CORE_EXPR_INFERENCE_VARIABLE:
        if (subtype.inference_variable.id == id) {
            return (struct dy_core_expr){
                .tag = DY_CORE_EXPR_END,
                .end_polarity = DY_CORE_POLARITY_NEGATIVE
            };
        } else {
            return subtype;
        }
    case DY_CORE_EXPR_CUSTOM:
        return subtype.custom.remove_mentions_in_subtype(subtype.custom.data, ctx, id);
    case DY_CORE_EXPR_END:
    case DY_CORE_EXPR_SYMBOL:
        return subtype;
    }

    dy_bail("Impossible object type.");
}

struct dy_core_expr remove_mentions_in_supertype(struct dy_core_ctx *ctx, size_t id, struct dy_core_expr supertype)
{
    switch (supertype.tag) {
    case DY_CORE_EXPR_EQUALITY_MAP:
        if (dy_core_expr_is_bound(id, *supertype.equality_map.e1)) {
            if (supertype.equality_map.polarity == DY_CORE_POLARITY_POSITIVE) {
                return (struct dy_core_expr){
                    .tag = DY_CORE_EXPR_END,
                    .end_polarity = DY_CORE_POLARITY_POSITIVE
                };
            } else {
                struct dy_core_expr type_map = {
                    .tag = DY_CORE_EXPR_TYPE_MAP,
                    .type_map = {
                        .binding = {
                            .id = ctx->running_id++,
                            .type = dy_core_expr_new(dy_type_of(ctx, *supertype.equality_map.e1)),
                        },
                        .expr = dy_core_expr_retain_ptr(supertype.equality_map.e2),
                        .polarity = DY_CORE_POLARITY_POSITIVE,
                        .is_implicit = supertype.equality_map.is_implicit,
                    }
                };

                struct dy_core_expr e = remove_mentions_in_supertype(ctx, id, type_map);

                dy_core_expr_release(type_map);

                return e;
            }
        }

        supertype.equality_map.e2 = dy_core_expr_new(remove_mentions_in_supertype(ctx, id, *supertype.equality_map.e2));
        return supertype;
    case DY_CORE_EXPR_TYPE_MAP:
        supertype.type_map.binding.type = dy_core_expr_new(remove_mentions_in_subtype(ctx, id, *supertype.type_map.binding.type));
        supertype.type_map.expr = dy_core_expr_new(remove_mentions_in_supertype(ctx, id, *supertype.type_map.expr));
        return supertype;
    case DY_CORE_EXPR_INFERENCE_TYPE_MAP:
        supertype.inference_type_map.binding.type = dy_core_expr_new(remove_mentions_in_subtype(ctx, id, *supertype.inference_type_map.binding.type));
        supertype.inference_type_map.expr = dy_core_expr_new(remove_mentions_in_supertype(ctx, id, *supertype.inference_type_map.expr));
        return supertype;
    case DY_CORE_EXPR_EQUALITY_MAP_ELIM:
        // fallthrough
    case DY_CORE_EXPR_ALTERNATIVE:
        // fallthrough
    case DY_CORE_EXPR_TYPE_MAP_ELIM:
        if (dy_core_expr_is_bound(id, supertype)) {
            return (struct dy_core_expr){
                .tag = DY_CORE_EXPR_END,
                .end_polarity = DY_CORE_POLARITY_POSITIVE
            };
        } else {
            return supertype;
        }
    case DY_CORE_EXPR_JUNCTION:
        supertype.junction.e1 = dy_core_expr_new(remove_mentions_in_supertype(ctx, id, *supertype.junction.e1));
        supertype.junction.e2 = dy_core_expr_new(remove_mentions_in_supertype(ctx, id, *supertype.junction.e2));
        return supertype;
    case DY_CORE_EXPR_RECURSION:
        supertype.recursion.expr = dy_core_expr_new(remove_mentions_in_supertype(ctx, id, *supertype.recursion.expr));
        return supertype;
    case DY_CORE_EXPR_VARIABLE:
        if (supertype.variable.id == id) {
            return (struct dy_core_expr){
                .tag = DY_CORE_EXPR_END,
                .end_polarity = DY_CORE_POLARITY_POSITIVE
            };
        } else {
            return supertype;
        }
    case DY_CORE_EXPR_INFERENCE_VARIABLE:
        if (supertype.inference_variable.id == id) {
            return (struct dy_core_expr){
                .tag = DY_CORE_EXPR_END,
                .end_polarity = DY_CORE_POLARITY_POSITIVE
            };
        } else {
            return supertype;
        }
    case DY_CORE_EXPR_CUSTOM:
        return supertype.custom.remove_mentions_in_supertype(supertype.custom.data, ctx, id);
    case DY_CORE_EXPR_END:
    case DY_CORE_EXPR_SYMBOL:
        return supertype;
    }

    dy_bail("Impossible object type.");
}

dy_array_t dy_deep_copy_bound_constraints(struct dy_core_ctx *ctx)
{
    dy_array_t copy = dy_array_create(sizeof(struct dy_bound_constraint), DY_ALIGNOF(struct dy_bound_constraint), ctx->bound_constraints.num_elems);

    for (size_t i = 0; i < ctx->bound_constraints.num_elems; ++i) {
        struct dy_bound_constraint bc;
        dy_array_get(ctx->bound_constraints, i, &bc);

        dy_array_t ids_copy = dy_array_create(sizeof(size_t), DY_ALIGNOF(size_t), bc.binding_ids.num_elems);
        for (size_t k = 0; k < bc.binding_ids.num_elems; ++k) {
            size_t id;
            dy_array_get(bc.binding_ids, k, &id);
            dy_array_add(&ids_copy, &id);
        }

        bc.binding_ids = ids_copy;

        dy_array_add(&copy, &bc);
    }

    return copy;
}

const struct dy_constraint *alloc_constraint(struct dy_constraint constraint)
{
    static const size_t pre_padding = DY_RC_PRE_PADDING(struct dy_constraint);
    static const size_t post_padding = DY_RC_POST_PADDING(struct dy_constraint);
    return dy_rc_new(&constraint, sizeof constraint, pre_padding, post_padding);
}
