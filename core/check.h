/*
 * Copyright 2017-2021 Thorben Hasenpusch <t.hasenpusch@icloud.com>
 *
 * SPDX-License-Identifier: MIT
 */

#pragma once

#include "constraint.h"
#include "core.h"
#include "type_of.h"
#include "is_subtype.h"
#include "eval.h"

#include "../support/bail.h"

/**
 * The functions here define the 'check' procedure for each object of Core.
 *
 * It has three purposes:
 *   (1) Update the subtype result of every elimination if needed.
 *   (2) Collect the constraints generated by (1).
 *   (3) Resolve inference contexts using the constraints of (2).
 *
 *  'check' is build as a pipeline:
 *   Expression comes in, validated & transformed expression + constraints come out.
 *
 *   Each check function returns true and the new expr in *result if the expr changed, false otherwise.
 */

static inline bool dy_check_expr(struct dy_core_ctx *ctx, struct dy_core_expr expr, struct dy_core_expr *result);

static inline bool dy_check_function(struct dy_core_ctx *ctx, struct dy_core_function function, struct dy_core_function *result);

static inline bool dy_check_pair(struct dy_core_ctx *ctx, struct dy_core_pair pair, struct dy_core_pair *result);

static inline bool dy_check_recursion(struct dy_core_ctx *ctx, struct dy_core_recursion recursion, bool is_implicit, struct dy_core_recursion *result);

static inline bool dy_check_solution(struct dy_core_ctx *ctx, struct dy_core_solution, struct dy_core_solution *result);

static inline bool dy_check_application(struct dy_core_ctx *ctx, struct dy_core_application application, struct dy_core_expr *result);

// Doesn't return a bool since an inference context is always resolved.
static inline struct dy_core_expr dy_check_inference_ctx(struct dy_core_ctx *ctx, struct dy_core_inference_ctx inference_ctx);

/**
 * Collects the id of every constraint that mentions 'id' and is not mutually recursive with it.
 * If the size of 'ids' isn't changed upon returning, 'id' is "free" and can be resolved.
 */
static inline void dy_collect_capturing_inference_vars(struct dy_core_ctx *ctx, size_t id, size_t constraint_start, dy_array_t *ids);

static inline bool dy_resolve_inference_var(struct dy_core_ctx *ctx, size_t id, enum dy_polarity polarity, struct dy_core_expr expr, size_t constraint_start, struct dy_core_expr *result);

static inline bool dy_resolve_now_free_inference_vars(struct dy_core_ctx *ctx, size_t id, enum dy_polarity polarity, struct dy_core_expr expr, size_t constraint_start, struct dy_core_expr *result);

static inline bool dy_constraint_binds_id(struct dy_core_ctx *ctx, size_t constraint_id, size_t id);

/**
 * Just removes 'id' from 'ids', if present.
 */
static inline void dy_remove_id(dy_array_t *ids, size_t id);

/**
 * Removes all mentions of 'id' in 'constraint', which may involve lowering/raising the subtype/supertype bounds.
 */
static inline void dy_remove_mentions_in_constraints(struct dy_core_ctx *ctx, size_t id, size_t start);

/**
 * Removes all mentions of 'id' in 'type'.
 */
static inline bool dy_remove_mentions_in_type(struct dy_core_ctx *ctx, size_t id, enum dy_polarity current_polarity, struct dy_core_expr type, struct dy_core_expr *result);

static inline dy_array_t dy_new_ids_array(struct dy_core_ctx *ctx);

static inline void dy_retire_ids_array(struct dy_core_ctx *ctx, dy_array_t array);

bool dy_check_expr(struct dy_core_ctx *ctx, struct dy_core_expr expr, struct dy_core_expr *result)
{
    switch (expr.tag) {
    case DY_CORE_EXPR_PROBLEM:
        switch (expr.problem.tag) {
        case DY_CORE_FUNCTION:
            if (dy_check_function(ctx, expr.problem.function, &expr.problem.function)) {
                *result = expr;
                return true;
            } else {
                return false;
            }
        case DY_CORE_PAIR:
            if (dy_check_pair(ctx, expr.problem.pair, &expr.problem.pair)) {
                *result = expr;
                return true;
            } else {
                return false;
            }
        case DY_CORE_RECURSION:
            if (dy_check_recursion(ctx, expr.problem.recursion, expr.problem.is_implicit, &expr.problem.recursion)) {
                *result = expr;
                return true;
            } else {
                return false;
            }
        }

        dy_bail("impossible");
    case DY_CORE_EXPR_SOLUTION:
        if (dy_check_solution(ctx, expr.solution, &expr.solution)) {
            *result = expr;
            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_APPLICATION:
        return dy_check_application(ctx, expr.application, result);
    case DY_CORE_EXPR_VARIABLE:
    case DY_CORE_EXPR_ANY:
    case DY_CORE_EXPR_VOID:
    case DY_CORE_EXPR_INFERENCE_VAR:
        return false;
    case DY_CORE_EXPR_INFERENCE_CTX:
        *result = dy_check_inference_ctx(ctx, expr.inference_ctx);
        return true;
    case DY_CORE_EXPR_CUSTOM: {
        const struct dy_core_custom_shared *vtab = dy_array_pos(&ctx->custom_shared, expr.custom.id);
        return vtab->check(ctx, expr.custom.data, result);
    }
    }

    dy_bail("Impossible object type.");
}

bool dy_check_function(struct dy_core_ctx *ctx, struct dy_core_function function, struct dy_core_function *result)
{
    size_t constraint_start1 = ctx->constraints.num_elems;
    struct dy_core_expr type;
    bool type_is_new = dy_check_expr(ctx, *function.type, &type);
    if (!type_is_new) {
        type = dy_core_expr_retain(ctx, *function.type);
    }

    dy_array_add(&ctx->free_variables, &(struct dy_free_var){
        .id = function.id,
        .type = type
    });

    size_t constraint_start2 = ctx->constraints.num_elems;
    struct dy_core_expr expr;
    bool expr_is_new = dy_check_expr(ctx, *function.expr, &expr);

    dy_remove_mentions_in_constraints(ctx, function.id, constraint_start2);

    --ctx->free_variables.num_elems;

    dy_join_constraints(ctx, constraint_start1, constraint_start2, DY_POLARITY_POSITIVE);

    if (!type_is_new && !expr_is_new) {
        dy_core_expr_release(ctx, type);
        return false;
    }

    if (type_is_new) {
        function.type = dy_core_expr_new(type);
    } else {
        dy_core_expr_release(ctx, type);
        dy_core_expr_retain_ptr(ctx, function.type);
    }

    if (expr_is_new) {
        function.expr = dy_core_expr_new(expr);
    } else {
        dy_core_expr_retain_ptr(ctx, function.expr);
    }

    *result = function;
    return true;
}

bool dy_check_pair(struct dy_core_ctx *ctx, struct dy_core_pair pair, struct dy_core_pair *result)
{
    size_t constraint_start1 = ctx->constraints.num_elems;
    struct dy_core_expr left;
    bool left_is_new = dy_check_expr(ctx, *pair.left, &left);

    size_t constraint_start2 = ctx->constraints.num_elems;
    struct dy_core_expr right;
    bool right_is_new = dy_check_expr(ctx, *pair.right, &right);

    dy_join_constraints(ctx, constraint_start1, constraint_start2, DY_POLARITY_POSITIVE);

    if (!left_is_new && !right_is_new) {
        return false;
    }

    if (left_is_new) {
        pair.left = dy_core_expr_new(left);
    } else {
        dy_core_expr_retain_ptr(ctx, pair.left);
    }

    if (right_is_new) {
        pair.right = dy_core_expr_new(right);
    } else {
        dy_core_expr_retain_ptr(ctx, pair.right);
    }

    *result = pair;
    return true;
}

bool dy_check_recursion(struct dy_core_ctx *ctx, struct dy_core_recursion recursion, bool is_implicit, struct dy_core_recursion *result)
{
    dy_array_add(&ctx->free_variables, &(struct dy_free_var){
        .id = recursion.id,
        .type = {
            .tag = DY_CORE_EXPR_VARIABLE,
            .variable_id = recursion.id
        }
    });

    size_t constraint_start = ctx->constraints.num_elems;

    struct dy_core_expr new_expr;
    bool expr_is_new = dy_check_expr(ctx, *recursion.expr, &new_expr);

    dy_remove_mentions_in_constraints(ctx, recursion.id, constraint_start);

    --ctx->free_variables.num_elems;

    if (!expr_is_new) {
        return false;
    }

    recursion.expr = dy_core_expr_new(new_expr);

    *result = recursion;

    return true;
}

bool dy_check_solution(struct dy_core_ctx *ctx, struct dy_core_solution solution, struct dy_core_solution *result)
{
    if (solution.tag == DY_CORE_FUNCTION) {
        size_t constraint_start1 = ctx->constraints.num_elems;
        struct dy_core_expr expr;
        bool expr_is_new = dy_check_expr(ctx, *solution.expr, &expr);

        size_t constraint_start2 = ctx->constraints.num_elems;
        struct dy_core_expr out;
        bool out_is_new = dy_check_expr(ctx, *solution.out, &out);

        dy_join_constraints(ctx, constraint_start1, constraint_start2, DY_POLARITY_POSITIVE);

        if (!expr_is_new && !out_is_new) {
            return false;
        }

        if (expr_is_new) {
            solution.expr = dy_core_expr_new(expr);
        } else {
            dy_core_expr_retain_ptr(ctx, solution.expr);
        }

        if (out_is_new) {
            solution.out = dy_core_expr_new(out);
        } else {
            dy_core_expr_retain_ptr(ctx, solution.out);
        }

        *result = solution;
        return true;
    } else {
        struct dy_core_expr out;
        if (!dy_check_expr(ctx, *solution.out, &out)) {
            return false;
        }

        solution.out = dy_core_expr_new(out);
        *result = solution;
        return true;
    }
}

bool dy_check_application(struct dy_core_ctx *ctx, struct dy_core_application application, struct dy_core_expr *result)
{
    size_t recovered_negative_inference_ids_start = ctx->recovered_negative_inference_ids.num_elems;

    size_t constraint_start1 = ctx->constraints.num_elems;
    struct dy_core_expr expr;
    bool expr_is_new = dy_check_expr(ctx, *application.expr, &expr);
    if (!expr_is_new) {
        expr = dy_core_expr_retain(ctx, *application.expr);
    }

    size_t constraint_start2 = ctx->constraints.num_elems;
    struct dy_core_solution solution;
    bool solution_is_new = dy_check_solution(ctx, application.solution, &solution);
    if (!solution_is_new) {
        solution = dy_core_solution_retain(ctx, application.solution);
    }

    dy_join_constraints(ctx, constraint_start1, constraint_start2, DY_POLARITY_POSITIVE);

    dy_ternary_t old_check_result = application.check_result;
    if (old_check_result == DY_MAYBE) {
        struct dy_core_expr type_of_expr = dy_type_of(ctx, expr);

        struct dy_core_expr solution_expr = {
            .tag = DY_CORE_EXPR_SOLUTION,
            .solution = solution
        };

        constraint_start2 = ctx->constraints.num_elems;

        bool did_transform_expr = false;
        struct dy_core_expr new_expr;
        application.check_result = dy_is_subtype(ctx, type_of_expr, solution_expr, expr, &new_expr, &did_transform_expr);
        if (did_transform_expr) {
            expr_is_new = true;
            dy_core_expr_release(ctx, expr);
            expr = new_expr;
        }

        dy_join_constraints(ctx, constraint_start1, constraint_start2, DY_POLARITY_POSITIVE);

        dy_core_expr_release(ctx, type_of_expr);
    }

    if (expr_is_new) {
        application.expr = dy_core_expr_new(expr);
    } else {
        dy_core_expr_release(ctx, expr);
        dy_core_expr_retain_ptr(ctx, application.expr);
    }

    if (solution_is_new) {
        application.solution = solution;
    } else {
        dy_core_solution_release(ctx, solution);
        dy_core_solution_retain(ctx, application.solution);
    }

    struct dy_core_expr app = {
        .tag = DY_CORE_EXPR_APPLICATION,
        .application = application
    };

    bool did_eval = false;

    if (application.eval_immediately) {
        struct dy_core_expr new_app;
        if (dy_eval_app_single_step(ctx, application, &new_app)) {
            dy_core_expr_release(ctx, app);
            app = new_app;
            did_eval = true;
        }
    }

    if (!expr_is_new && !solution_is_new && old_check_result == application.check_result && !did_eval) {
        return false;
    } else {
        for (size_t i = ctx->recovered_negative_inference_ids.num_elems; i-- > recovered_negative_inference_ids_start;) {
            size_t id = *(size_t *)dy_array_pos(&ctx->recovered_negative_inference_ids, i);

            struct dy_core_expr new_app;
            if (dy_resolve_inference_var(ctx, id, DY_POLARITY_NEGATIVE, app, constraint_start1, &new_app)) {
                dy_core_expr_release(ctx, app);
                app = new_app;
            }
        }

        ctx->recovered_negative_inference_ids.num_elems = recovered_negative_inference_ids_start;

        *result = app;

        return true;
    }
}

struct dy_core_expr dy_check_inference_ctx(struct dy_core_ctx *ctx, struct dy_core_inference_ctx inference_ctx)
{
    size_t constraint_start = ctx->constraints.num_elems;

    struct dy_core_expr expr;
    if (!dy_check_expr(ctx, *inference_ctx.expr, &expr)) {
        expr = dy_core_expr_retain(ctx, *inference_ctx.expr);
    }

    struct dy_core_expr expr2;
    if (dy_resolve_inference_var(ctx, inference_ctx.id, inference_ctx.polarity, expr, constraint_start, &expr2)) {
        dy_core_expr_release(ctx, expr);
        expr = expr2;
    }

    return expr;
}

void dy_collect_capturing_inference_vars(struct dy_core_ctx *ctx, size_t id, size_t constraint_start, dy_array_t *ids)
{
    for (size_t i = constraint_start; i < ctx->constraints.num_elems; ++i) {
        const struct dy_constraint *c = dy_array_pos(&ctx->constraints, i);
        if (c->id == id) {
            continue;
        }

        bool duplicate = false;
        for (size_t k = 0, size2 = ids->num_elems; k < size2; ++k) {
            if (c->id == *(const size_t *)dy_array_pos(ids, k)) {
                duplicate = true;
                break;
            }
        }
        if (duplicate) {
            continue;
        }

        if (((c->have_lower && dy_core_expr_contains_this_variable(ctx, id, c->lower)) || (c->have_upper && dy_core_expr_contains_this_variable(ctx, id, c->upper))) && !dy_constraint_binds_id(ctx, id, c->id)) {
            dy_array_add(ids, &c->id);
        }
    }
}

bool dy_resolve_now_free_inference_vars(struct dy_core_ctx *ctx, size_t id, enum dy_polarity polarity, struct dy_core_expr expr, size_t constraint_start, struct dy_core_expr *result)
{
    struct dy_core_expr ret = dy_core_expr_retain(ctx, expr);

    bool did_transform = false;
    for (size_t i = ctx->captured_inference_vars.num_elems; i-- > 0;) {
        struct dy_captured_inference_var *captured_inference_var = dy_array_pos(&ctx->captured_inference_vars, i);

        dy_remove_id(&captured_inference_var->captor_ids, id);

        if (captured_inference_var->captor_ids.num_elems != 0) {
            // Still captured.
            continue;
        }

        dy_retire_ids_array(ctx, captured_inference_var->captor_ids);

        size_t captured_id = captured_inference_var->id;

        dy_array_remove(&ctx->captured_inference_vars, i);

        struct dy_core_expr ret2;
        if (dy_resolve_inference_var(ctx, captured_id, polarity, ret, constraint_start, &ret2)) {
            did_transform = true;
            dy_core_expr_release(ctx, ret);
            ret = ret2;
        }

        i = ctx->captured_inference_vars.num_elems;
    }

    if (!did_transform) {
        dy_core_expr_release(ctx, ret);
        return false;
    } else {
        *result = ret;
        return true;
    }
}

bool dy_resolve_inference_var(struct dy_core_ctx *ctx, size_t id, enum dy_polarity polarity, struct dy_core_expr expr, size_t constraint_start, struct dy_core_expr *result)
{
    dy_array_t captor_ids = dy_new_ids_array(ctx);
    dy_collect_capturing_inference_vars(ctx, id, constraint_start, &captor_ids);

    if (captor_ids.num_elems != 0) {
        dy_array_add(&ctx->captured_inference_vars, &(struct dy_captured_inference_var){
            .id = id,
            .captor_ids = captor_ids,
        });

        return false;
    }

    dy_retire_ids_array(ctx, captor_ids);

    struct dy_core_expr sub;
    bool have_sub = dy_constraint_get(ctx, id, polarity, constraint_start, &sub);

    struct dy_core_expr type_of_expr = dy_type_of(ctx, expr);

    bool positive = false, negative = false;
    dy_variable_appears_in_polarity(ctx, type_of_expr, id, DY_POLARITY_POSITIVE, &positive, &negative);

    dy_core_expr_release(ctx, type_of_expr);

    struct dy_core_expr any = {
        .tag = DY_CORE_EXPR_ANY
    };

    if (positive && negative) {
        if (have_sub) {
            struct dy_core_expr pair = {
                .tag = DY_CORE_EXPR_PROBLEM,
                .problem = {
                    .is_implicit = true,
                    .polarity = DY_POLARITY_POSITIVE,
                    .tag = DY_CORE_PAIR,
                    .pair = {
                        .left = dy_core_expr_new(sub),
                        .right = dy_core_expr_new((struct dy_core_expr){
                            .tag = DY_CORE_EXPR_VARIABLE,
                            .variable_id = id
                        })
                    }
                }
            };

            if (!dy_substitute(ctx, expr, id, pair, &expr)) {
                expr = dy_core_expr_retain(ctx, expr);
            }
        } else {
            struct dy_core_expr v = {
                .tag = DY_CORE_EXPR_VARIABLE,
                .variable_id = id
            };

            if (!dy_substitute(ctx, expr, id, v, &expr)) {
                expr = dy_core_expr_retain(ctx, expr);
            }
        }

        expr = (struct dy_core_expr){
            .tag = DY_CORE_EXPR_PROBLEM,
            .problem = {
                .polarity = DY_POLARITY_POSITIVE,
                .is_implicit = true,
                .tag = DY_CORE_FUNCTION,
                .function = {
                    .id = id,
                    .type = dy_core_expr_new(dy_core_expr_retain(ctx, any)),
                    .expr = dy_core_expr_new(expr)
                }
            }
        };
    } else {
        if (!dy_substitute(ctx, expr, id, have_sub ? sub : any, &expr)) {
            expr = dy_core_expr_retain(ctx, expr);
        }
    }

    dy_free_constraints_starting_at(ctx, constraint_start);

    struct dy_core_expr new_expr;
    if (dy_check_expr(ctx, expr, &new_expr)) {
        dy_core_expr_release(ctx, expr);
        expr = new_expr;
    }

    if (dy_resolve_now_free_inference_vars(ctx, id, polarity, expr, constraint_start, &new_expr)) {
        dy_core_expr_release(ctx, expr);
        expr = new_expr;
    }

    *result = expr;
    return true;
}

void dy_remove_id(dy_array_t *ids, size_t id_to_remove)
{
    for (size_t i = 0, size = ids->num_elems; i < size; ++i) {
        size_t id = *(size_t *)dy_array_pos(ids, i);

        if (id == id_to_remove) {
            dy_array_remove(ids, i);
            return;
        }
    }
}

void dy_remove_mentions_in_constraints(struct dy_core_ctx *ctx, size_t id, size_t start)
{
    for (size_t i = start, size = ctx->constraints.num_elems; i < size; ++i) {
        struct dy_constraint *c = dy_array_pos(&ctx->constraints, i);

        struct dy_core_expr e;
        if (c->have_lower && dy_remove_mentions_in_type(ctx, id, DY_POLARITY_POSITIVE, c->lower, &e)) {
            dy_core_expr_release(ctx, c->lower);
            c->lower = e;
        }

        if (c->have_upper && dy_remove_mentions_in_type(ctx, id, DY_POLARITY_NEGATIVE, c->upper, &e)) {
            dy_core_expr_release(ctx, c->upper);
            c->upper = e;
        }
    }
}

bool dy_remove_mentions_in_type(struct dy_core_ctx *ctx, size_t id, enum dy_polarity current_polarity, struct dy_core_expr type, struct dy_core_expr *result)
{
    switch (type.tag) {
    case DY_CORE_EXPR_PROBLEM:
        switch (type.problem.tag) {
        case DY_CORE_FUNCTION: {
            struct dy_core_expr t;
            bool type_is_new = dy_remove_mentions_in_type(ctx, id, dy_flip_polarity(current_polarity), *type.problem.function.type, &t);

            struct dy_core_expr expr;
            bool expr_is_new = dy_remove_mentions_in_type(ctx, id, current_polarity, *type.problem.function.expr, &expr);

            if (!type_is_new && !expr_is_new) {
                return false;
            }

            if (type_is_new) {
                type.problem.function.type = dy_core_expr_new(t);
            } else {
                dy_core_expr_retain_ptr(ctx, type.problem.function.type);
            }

            if (expr_is_new) {
                type.problem.function.expr = dy_core_expr_new(expr);
            } else {
                dy_core_expr_retain_ptr(ctx, type.problem.function.expr);
            }

            *result = type;
            return true;
        }
        case DY_CORE_PAIR: {
            struct dy_core_expr left;
            bool left_is_new = dy_remove_mentions_in_type(ctx, id, current_polarity, *type.problem.pair.left, &left);

            struct dy_core_expr right;
            bool right_is_new = dy_remove_mentions_in_type(ctx, id, current_polarity, *type.problem.pair.right, &right);

            if (!left_is_new && !right_is_new) {
                return false;
            }

            if (left_is_new) {
                type.problem.pair.left = dy_core_expr_new(left);
            } else {
                dy_core_expr_retain_ptr(ctx, type.problem.pair.left);
            }

            if (right_is_new) {
                type.problem.pair.right = dy_core_expr_new(right);
            } else {
                dy_core_expr_retain_ptr(ctx, type.problem.pair.right);
            }

            *result = type;
            return true;
        }
        case DY_CORE_RECURSION: {
            struct dy_core_expr expr;
            if (!dy_remove_mentions_in_type(ctx, id, current_polarity, *expr.problem.recursion.expr, &expr)) {
                return false;
            }

            type.problem.recursion.expr = dy_core_expr_new(expr);

            *result = type;
            return true;
        }
        }

        dy_bail("impossible");
    case DY_CORE_EXPR_SOLUTION:
        if (type.solution.tag == DY_CORE_FUNCTION && dy_core_expr_contains_this_variable(ctx, id, *type.solution.expr)) {
            struct dy_core_expr fun = {
                .tag = DY_CORE_EXPR_PROBLEM,
                .problem = {
                    .is_implicit = type.solution.is_implicit,
                    .polarity = dy_flip_polarity(current_polarity),
                    .tag = DY_CORE_FUNCTION,
                    .function = {
                        .id = ctx->running_id++,
                        .type = dy_core_expr_new(dy_type_of(ctx, *type.solution.expr)),
                        .expr = dy_core_expr_retain_ptr(ctx, type.solution.out)
                    }
                }
            };

            if (dy_remove_mentions_in_type(ctx, id, current_polarity, fun, result)) {
                dy_core_expr_release(ctx, fun);
            } else {
                *result = fun;
            }

            return true;
        } else {
            struct dy_core_expr out;
            if (!dy_remove_mentions_in_type(ctx, id, current_polarity, *type.solution.out, &out)) {
                return false;
            }

            type.solution.out = dy_core_expr_new(out);

            *result = type;
            return true;
        }
    case DY_CORE_EXPR_APPLICATION:
        if (dy_core_expr_contains_this_variable(ctx, id, type)) {
            *result = (struct dy_core_expr){
                .tag = DY_CORE_EXPR_ANY
            };

            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_VARIABLE:
        if (type.variable_id == id) {
            *result = (struct dy_core_expr){
                .tag = DY_CORE_EXPR_ANY
            };

            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_INFERENCE_VAR:
        if (type.inference_var_id == id) {
            *result = (struct dy_core_expr){
                .tag = DY_CORE_EXPR_ANY
            };

            return true;
        } else {
            return false;
        }
    case DY_CORE_EXPR_ANY:
    case DY_CORE_EXPR_VOID:
        return false;
    case DY_CORE_EXPR_INFERENCE_CTX:
        dy_bail("impossible");
    case DY_CORE_EXPR_CUSTOM: {
        const struct dy_core_custom_shared *s = dy_array_pos(&ctx->custom_shared, type.custom.id);
        return s->remove_mentions_in_type(ctx, type.custom.data, id, current_polarity, result);
    }
    }

    dy_bail("Impossible object type.");
}

dy_array_t dy_new_ids_array(struct dy_core_ctx *ctx)
{
    if (ctx->free_ids_arrays.num_elems == 0) {
        return dy_array_create(sizeof(size_t), DY_ALIGNOF(size_t), 4);
    } else {
        dy_array_t x;
        dy_array_pop(&ctx->free_ids_arrays, &x);
        return x;
    }
}

void dy_retire_ids_array(struct dy_core_ctx *ctx, dy_array_t array)
{
    dy_array_add(&ctx->free_ids_arrays, &array);
}

bool dy_constraint_binds_id(struct dy_core_ctx *ctx, size_t constraint_id, size_t id)
{
    for (size_t i = 0; i < ctx->constraints.num_elems; ++i) {
        const struct dy_constraint *c = dy_array_pos(&ctx->constraints, i);
        if (c->id != constraint_id) {
            continue;
        }

        if (c->have_lower && c->lower.tag == DY_CORE_EXPR_INFERENCE_VAR && c->lower.inference_var_id == id) {
            return true;
        }

        if (c->have_upper && c->upper.tag == DY_CORE_EXPR_INFERENCE_VAR && c->upper.inference_var_id == id) {
            return true;
        }

        return false;
    }

    return false;
}
