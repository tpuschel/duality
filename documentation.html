<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="utf-8">

  <link rel="stylesheet" href="styles.css">

  <title>The Duality Programming Language - Documentation</title>

  <link rel="icon" href="favicon.png">
</head>

<body>
  <header>
    <nav id="navBar">
      <a href="/index.html">Home</a>
      <a class="current-link" href="/documentation.html">Documentation</a>
      <a href="/downloads.html">Downloads</a>
      <a href="https://github.com/tpuschel/duality">Source on GitHub</a>
    </nav>
  </header>

  <main>
    <h3> Page is under construction! </h3>

    <h4> Basics </h4>

    <p>
      Every Duality program is an <em>expression</em>. An expression can be evaluated; that is, reduced to another
      expression according to certain rules. Furthermore, all expressions have a built-in concept of <em>equality</em>
      and of their <em>type</em>:
    </p>

    <ul>
      <li>
        <p>
          Equality is the concept of distinguishing one expression from another.
        </p>
        <p>
          Any expression can be substituted for an equal expression without evaluation behaving differently at all.
        </p>
        <p>
          Fundamentally, an expression is always equal to itself.
        </p>
      </li>

      <li>
        <p>
          A type is a description of how an expression can be used.
        </p>
        <p>
          Every time an expression is used, its type's compatibility to the expected type is tested.
          This relation is called <em>subtyping</em>, and is syntactically represented by <code>&lt;:</code>.
        </p>
        <p>
          Very importantly, types themselves are also expressions.
        </p>
      </li>
    </ul>

    <h4> Maps </h4>

    <p>
      There are two fundamental constructs in Duality that make use of equality and types to drive evaluation:
      <ul>
        <li>
          <p>
            Equality maps.
          </p>

          <p>
            Grammar: <code> &lt;expr&gt; -> &lt;expr&gt; </code>
          </p>

          <p>
            Type: <code> type(e1 -> e2) => e1 -> type(e2) </code>
          </p>

          <p>
            An equality map maps one expression to another. For example, <code> "answer" -> "42" </code> is an example
            of a equality map.
          </p>
        </li>
        <li>
          <p>
            Type maps.
          </p>

          <p>
            Grammar: <code> [&lt;variable&gt; &lt;expr&gt;] -> &lt;expr&gt; </code>
          </p>

          <p>
            Type:
            <code> type([var e1] -> e2) => [var e1] -> type(e2) </code>
          </p>

          <p>
            Type maps are very similar to equality maps, only they map expressions <em>of a certain type</em> to another
            expression. <code>[s String] -> print s</code> is an example of a type map.
          </p>

          <p>

          </p>
        </li>
      </ul>
    </p>

    <h4> Elimination </h4>

    <p>
      Elimination is the process of "using" something. Its purpose is to provide appropriate "input" to a map so that
      it can be reduced to its "output" part, thus driving evaluation.
    </p>

    <p>
      Mirroring the two kinds of maps, there are two kinds of eliminations, depending on what kind of map is used
      as the eliminator.
    </p>

    <ul>
      <li>
        <p>
          Equality map elimination.
        </p>

        <p>
          Grammar: <code> &lt;expr&gt; ! &lt;expr&gt; ~> &lt;expr&gt; </code>
        </p>

        <p>
          Type: <code> type(e1 ! e2 ~> e3) => e3 </code>
        </p>

        <p>

        </p>
      </li>

      <li>
        <p>
          Type map elimination.
        </p>

        <p>
          Grammar: <code> &lt;expr&gt; ! [&lt;variable&gt; &lt;expr&gt;] ~> &lt;expr&gt; </code>
        </p>

        <p>
          Type: <code> type(e1 ! [var e2] ~> e3) => e3 </code>
        </p>
      </li>
    </ul>

    <p style="margin-top: 20em;">
      [The following will be reworked and split up at some point]
    </p>

    <p>
      In particular, Duality generalizes the following concepts commonly found in other languages:
    </p>

    <ul>
      <li>
        <p>
          Static and dynamic typing.
        </p>
        <p>
          In Duality, there is no difference between checking a program for correctness
          before a program has begun evaluating ("at compile time", or static) or after ("at run time", or dynamic).
        </p>
        <p>
          Likewise, the representation of an expression in Duality does not differ between the checking
          and evaluating phases. That means that types exist at 'run time' just as much as at 'compile time'.
        </p>
        <p>
          As a consequence of this design, types can influence program behavior both at all and uniformly in the
          static and the dynamic dimension.
        </p>
      </li>

      <li>
        <p>
          Named-field objects ("structs", "records" etc.).
        </p>
        <p>
          Fundamentally, something like a record combines the notion of 'multiple things' and the notion of a
          map from a label to an expression. Even though a record is a combination (or composition) of
          pre-existing notions, in most all languages these individual notions are not themselves independent
          entities.
        </p>
        <p>
          In Duality, the notion of 'multiple things' is represented by the construct called 'list', and the notion of
          a map from a label to an expression is generalized to a map from an expression to another expression.
          The entities that represent these notions are independently manipulable, and what other languages call a
          record is simply the emergent behavior of two entirely orthogonal constructs.
        </p>
      </li>

      <li>
        <p>
          Direct branching ("if-else", "switch-case", pattern matching).
        </p>
        <p>
          In languages that feature it, pattern matching generalizes constructs such as "if-else" or "switch-case".
        </p>
        <p>
          Duality goes one step further and recognizes that pattern matching, similar to the record situation, is
          a combination of two existing notions that are much better off disentangled and given simple, irreducible
          semantics.
        </p>
        <p>
          First, the 'arm' of each pattern match can be more simply restated as just elimination. That is, application
          of maps to arguments and so on.
        </p>
        <p>
          Second, the nature of pattern matching execution as 'first try this arm, then the next, etc..' can be
          restated more generally as a construct that acts upon the validity of its constituents, choosing the next
          one as soon as the current one is determined to be invalid. In Duality, this is represented by the 'try'
          construct which acts upon the information of the checking procedure to either reduce to or discard its
          constituent expressions.
        </p>
      </li>

      <li>
        <p>
          Equality.
        </p>
        <p>
          Most languages feature operations or functions that determine the equality of its entities in a Boolean
          fashion.
        </p>
        <p>
          In Duality, no such pre-existing operations exist. In particular, there is not even a Boolean type.
        </p>
        <p>
          As a consequence of the record situation, Duality introduced a kind of map that maps one expression to
          another. This kind of map is used just like any other: by elimination ('applying to an argument').
          The validity of such an elimination is determined by the equality of the input expression of the map and the
          argument to the elimination.
        </p>
        <p>
          And just like any elimination, the validity thereof is determined by the checking procedure. Thus, just like
          checking the compatibility of types in the case of type maps ('functions'), the checking procedure provides
          the information upon which the rest of the program can act (see 'Direct branching' above).
        </p>
      </li>

      <li>
        <p>
          Inheritance and indirect branching.
        </p>
        <p>
          In nominally typed languages, inheritance is an explicit relationship applied at the type level.
          It's used to represent the idea of an object partly being defined in another object's terms.
        </p>
        <p>
          Duality, being a structurally typed language, fundamentally does not require explicit relationships
          on a type level, nor does it follow the instantiation way of constructing objects.
        </p>
        <p>
          Instead, Duality uses the 'list' construct to represent 'multiple things'.
          These are unlike lists in other languages, and importantly, unlike tuples in languages like ML.
          In every situation where a 'list' object is "used" (meaning, eliminated), it behaves like the first
          object in the list that can be successfully eliminated.
        </p>
      </li>
    </ul>
  </main>
</body>

</html>